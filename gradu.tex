% !TeX encoding = latin1
%
% [ Tiedostossa k‰ytetty merkistˆ on ISO 8859-1 eli Latin 1. Yll‰oleva rivi ]
% [ tarvitaan, jos k‰ytt‰‰ MiKTeX-paketin mukana tulevaa TeXworks-editoria. ]
%
% Laatinut Timo M‰nnikkˆ
%
% Jos kirjoitat pro gradu -tutkielmaa, tee mallipohjaan seuraavat muutokset:
%  - Poista dokumenttiluokasta optio shortthesis .
%  - Poista makro \tyyppi .
%  - Lis‰‰ suuntautumisvaihtoehto makrolla \linja .
%  - Kirjoita ylimm‰n tason otsikot makrolla \chapter, toisen tason otsikot
%    makrolla \section ja mahdolliset kolmannen tason otsikot makrolla
%    \subsection .

\documentclass[finnish,nonumbib,nocopyright]{gradu2}

\usepackage{palatino} % valitaan oletusfonttia hieman tyylikk‰‰mpi fontti

\usepackage[pdftex]{graphicx}
\usepackage{epstopdf}

\title{Behaviour-driven development mobiiliohjelmistojen kehityksen tukena}
\translatedtitle{Using behaviour-driven development to support software development on mobile platforms}

\setauthor{Samppa}{Hynninen}
\yhteystiedot{samppa.hynninen@jyu.fi}

\setdate{23}{04}{2014}

\tiivistelma{T‰h‰n tulee tutkielman tiivistelm‰.}
\abstract{Here comes the abstract of the thesis.}

\avainsanat{bdd, behariour-driven development, mobiilialustat}    % korvaa n‰m‰ oikeilla
\keywords{bdd, behariour-driven development, mobile platforms} % avainsanoilla

\linja{Ohjelmisto- ja tietoliikennetekniikka}

\begin{document}

\mainmatter

\chapter{Johdanto}

L‰hivuosina erilaisten mobiilip‰‰tteiden osuus kuluttajien k‰ytt‰mist‰ laitteista on kasvanut r‰j‰hdysm‰isesti. Perinteisten pˆyt‰tietokoneiden, kannettavien tietokoneiden ja matkapuhelinten v‰liin on syntynyt t‰ysin uusia laiteryhmi‰, kuten esimerkiksi tablet-tietokoneet. Ohjelmistoteollisuus on joutunut muuntautumaan uusiin vaatimuksiin, jotka uudenlaiset sovellusalustat ovat tuoneet mukanaan. Palvelujen tulee nyky‰‰n monesti olla k‰ytett‰viss‰ useilla eri alustoilla ja erilaisia alustoja voivat koskea erilaiset vaatimukset. Ohjelmistokehitysmenetelmi‰ on jouduttu kehitt‰m‰‰n jatkuvasti muuttuvan ymp‰ristˆn ja uusien tarpeiden myˆt‰. Behaviour-driven development, eli k‰ytt‰ytymisl‰htˆinen kehitys on yksi viime vuosina kehittyneist‰ ohjelmistokehityst‰ tukevista tekniikoista, jossa kehityksen l‰htˆkohtana ovat m‰‰rittelyt siit‰, kuinka ohjelmiston tulisi toimia ja k‰ytt‰yty‰.

Ohjelmistotestauksen ollessa kriittinen osa ohjelmistotuotantoprosessia ja erityisesti laadunvarmistusta, sen merkitys korostuu entisest‰‰n, kun ohjelmistoja toimitetaan useille eri alustoille. T‰ss‰ tutkielmassa k‰sitell‰‰n behaviour-driven developmentia ja sen taustoja niin menetelm‰llisest‰ kuin puhtaasti teknologisesta n‰kˆkulmasta. Aluksi selvitet‰‰n mit‰ BDD:ll‰ tarkoitetaan ja mist‰ se on kehittynyt. Taustojen ja historian ohella katselmoidaan ohjelmistokehityksen haasteita ja ongelmakohtia, joita BDD:n avulla pyrit‰‰n v‰ltt‰m‰‰n. Teknologioiden osalta k‰sitell‰‰n erityisesti BDD-testaamista mobiiliohjelmistojen kehityksess‰ ja sen poikkeavuuksia sek‰ erityispiirteit‰ verrattuna BDD-menetelmiin muissa ymp‰ristˆiss‰. T‰ss‰ yhteydess‰ tarkastellaan erikseen eri mobiilialustojen natiivisovelluksia sek‰ uusiin HTML5-teknologioihin pohjautuvia alustariippumattomia sovelluksia, sill‰ niiden testaaminen eroaa merkitt‰v‰sti toisistaan. 

T‰m‰n pro gradu -tutkielman tavoitteena on kartoittaa behaviour-driven developmentin tarjoamia mahdollisuuksia helpottaa mobiiliohjelmistojen kehityst‰ ja erityisesti testausta. Tarkoituksena on selvitt‰‰ millaisia BDD-testikehyksi‰ merkitt‰vimmille mobiilialustoille on t‰ll‰ hetkell‰ olemassa ja miten eri mobiilialustojen testikehykset poikkeavat toisistaan. T‰m‰ lis‰ksi tarkoituksena on selvitt‰‰, millaisia liiketoiminnallisia etuja BDD:ll‰ voidaan mobiilisovelluskehityksess‰ saavuttaa. Tutkielma toteutetaan k‰ytt‰en konstruktiivista tutkimusotetta ja siin‰ pyrit‰‰n lopputuloksena toteuttamaan ymp‰ristˆ, jossa samaa sovellusta voitaisiin testataan eri mobiilialustoilla yhdell‰ testikokoelmalla. Testiymp‰ristˆn toteutuksen yhteydess‰ tutkitaan millaisia puutteita nykyratkaisuissa on ja miten niit‰ voitaisiin kehitt‰‰, jotta yhden testikokoelman mallia voitaisiin k‰ytt‰‰.

\chapter{Tutkimuksesta}
\section{Termej‰}
\begin{itemize}
\item Apache Cordova: Avoimen l‰hdekoodin ohjelmisto, johon PhoneGap perustuu.
\item ATDD: Acceptance test-driven development. Hyv‰ksymistestil‰htˆinen ohjelmistokehitys.
\item BDD: Behaviour-driven development. K‰ytt‰ytymisl‰htˆinen kehitys. Ohjelmistokehitysprosessi, jossa vaatimukset pohjautuvat ohjelmiston k‰ytt‰ytymiseen.
\item CI: Continuous Integration, jatkuva integraatio.
\item Cucumber: Rubylla kirjoitettu BDD-testikehys.
\item HTML5: HTML-merkint‰kielen uusin versio ja samalla k‰site nykyaikaisille web-teknologioille, kuten JavaScriptille ja CSS3:lle.
\item Jasmine: BDD-testikehys JavaScript-ohjelmointikielelle.
\item JBehave: Yksi ensimm‰isist‰ BDD-testikehyksist‰ Java-ohjelmointikielelle.
\item Natiivisovellus: Jonkin sovellusalustan omalla kehitysymp‰ristˆll‰ ja ohjelmointikielell‰ toteutettu sovellus.
\item PhoneGap: Adoben omistama mobiiliohjelmistokehys, jolla voidaan toteuttaa monialustaisia sovelluksia moderneilla web-teknologioilla.
\item RSpec: BDD-testikehys Ruby-ohjelmointikielelle.
\item Selenium: Tyˆkalu verkkoselaimen automatisointiin.
\item TDD: Test-driven development. Testivetoinen kehitys, ohjelmistokehityksen prosessi, jossa testit kirjoitetaan ennen ohjelmakoodia
\end{itemize}

\section{Aikaisemmat tutkimukset}
Aikaisempaa tieteellist‰ tutkimusta Behaviour-driven developmentista on tehty verrattain v‰h‰n, sill‰ aihepiiri on niin tuore. Termin‰ BDD on tullut k‰yttˆˆn ensimm‰isi‰ kertoja vasta 2000-luvun puoliv‰liss‰ erirtyisesti Dan Northin blogitekstien myˆt‰ \cite{bddintro}. T‰ten voidaan laskea BDD:n olevan k‰sitteen‰kin vasta noin kymmenen vuoden ik‰inen.

Hakiessani l‰hteit‰ ja aikaisempia tutkimuksia BDD:n aihepiireist‰ k‰ytin p‰‰asiallisesti suurimpia tietokantoja etsimiseen. N‰it‰ olivat ACM Digital Library, IEEE Xplore, Google Scholar. Aloitin haut tekem‰ll‰ muutamia avainsanahakuja \cite{tutkimuspaska} eri tietokantoihin. Termill‰ ``bdd'' tehdyt haut eiv‰t tuottaneet juuri mist‰‰n kannasta toivottuja tuloksia, sill‰ lyhennett‰ ilmeisesti k‰ytet‰‰n monilla muillakin tieteenaloilla tarkoittamaan eri asiaa. Avainsanahaussa hakusanat ``behaviour driven development'' tuottivat jo selv‰sti paremman tuloksen. Google Scholar palautti kyselyll‰ noin 250 tulosta, joista suuri osa oli relevantteja. IEEE Xploresta ei samoilla hakutermeill‰ ja sen variaatioilla palautunut kuin kaksi eri julkaisua. ACM:n hausta termeill‰ ja niiden muutamalla variaatiolla (esim. ``behavior driven development'') palautui noin kaksikymment‰ tulosta.

Hauilla lˆytyneet tutkimukset pystyi karkeasti jakamaan muutamaan eri luokkaan. Ensimm‰iseen ryhm‰‰n kuuluvissa tutkimuksissa keskityttiin l‰hinn‰ m‰‰rittelem‰‰n Behaviour-driven developmentia ja ylip‰‰ns‰ siihen liittyv‰‰ termistˆ‰. N‰iss‰ tutkimuksissa ja l‰hteiss‰ aihepiiri oli ik‰‰nkuin uusi ja viel‰ vakiintumaton. Toisen p‰‰teeman lˆytyneiss‰ tutkimuksissa muodostavat l‰hteet, joissa BDD:n tehokkuutta ja sopivuutta on tutkittu eri tilanteissa. T‰h‰n teemaan lukeutuvat myˆs tutkimukset, joissa BDD:n menetelmi‰ sovelletaan jollekin tietylle toimialalle.

Sopivimmille artikkeleille tein lis‰hakuja k‰ytt‰en ``Backward search''-menetelm‰‰ \cite{tutkimuspaska}, jossa k‰vin l‰pi lˆytyneiden tutkimusten l‰hteit‰. T‰ll‰ tavoin lˆytyi muutamia l‰hteit‰, jotka esiintyiv‰t hyvin monissa BDD:hen liittyviss‰ tutkimuksissa. N‰it‰ olivat esimerkiksi Dan Northin tekstit \cite{bddintro}, Gojko Adzicin kirjat \cite{bridging},\cite{specification} sek‰ esimerkiksi Cucumber-kirja \cite{cucumber}. Samanlaisia tuloksia lˆytyi, kun k‰vin l‰hteille l‰pi viel‰ ``Backward search''-menetelm‰‰, mutta t‰ll‰ kertaa keskittyen kirjoittajiin, eli tutkin kirjoittajien muita teoksia.

N‰iden hakujen myˆt‰ p‰‰dyin k‰ytt‰m‰‰n l‰htein‰ erityisesti usein esilletulleita teoksia, kuten Adzicin kirjat, Cucumber-kirja sek‰ Dan Northin kirjoitukset. T‰m‰n lis‰ksi mukaan valikoitui kirjoittaessa jatkuvasti uusia l‰hteit‰, joita lˆytyi ennen kaikkea tekem‰ll‰ ``Backward search''-hakuja aineistolle.

\section{Tutkimusmenetelmist‰}
Tutkimus on toteutettu k‰ytt‰en konstruktiivista tutkimusotetta. Konstruktiivisessa tutkimusotteessa tavoitteena on rakentaa jonkinlainen artefakti, joka ratkaisee jonkin tietyn alan kysymyksen ja t‰t‰ kautta lis‰‰ tietoa ongelmasta ja sen ratkaisusta alalla \cite{constructive}. Tutkielmassani yrit‰n lˆyt‰‰ ratkaisua kysymykseen, voidaanko t‰m‰nhetkisten modernien mobiilialustojen ohjelmistoja testata tehokkaasti k‰ytt‰en Behaviour-driven developmentin toimintatapoja.

Tutkimuskysymykseen vastatakseni tutkimuksessa kartoitetaan ensiksi millaisia BDD-tyˆkaluja mobiilialustoille on nyky‰‰n saatavilla. Tutkimuksessani k‰ytett‰v‰t alustat olen rajannut kattamaan kolme suosituinta alustaa Gartnerin tutkimuksen pohjalta (Q4/2013) \cite{marketshare}. Kolme mukaan otettua alustaa olivat Googlen Android, Applen iOS ja Microsoftin Windows Phone. T‰m‰n j‰lkeen teht‰v‰n‰ oli kartoittaa valituille alustoille t‰ll‰ hetkell‰ olemassa olevia BDD:n mahdollistavia ratkaisuja. Lˆydettyj‰ ratkaisuja k‰yd‰‰n l‰pi luvussa \ref{chap:platforms}.

Olemassa olevien ratkaisuiden kartoittamisen myˆt‰ tutkielmassa tutkittiin onko mahdollisesti jo olemassa BDD-testikehyksi‰, joilla voidaan testata kerralla useita eri alustoja. Samalla tutkittiin onko eri mobiilialustoille lˆydett‰viss‰ sellaisia BDD-testikehyksi‰, joiden k‰ytt‰m‰ luonnollinen kieli toimisi niin, ett‰ samoilla luonnollisella kielell‰ kirjoitetuilla testeill‰ voisi ainoastaan eri testikehysten kielt‰ j‰sent‰v‰‰ ohjelmakoodia muokkaamalla saada samat testit toimimaan eri testikehyksill‰.

T‰m‰n j‰lkeen tutkimuksessa k‰yd‰‰n viel‰ l‰pi erikseen ratkaisu ongelmaan, kun kyseess‰ ovat natiivisovellusten sijaan HTML5-sovellukset, sill‰ n‰iden kohdalla testaus voidaan suorittaa eri tavalla. Tutkimuksessa kartoitetaan HTML5-sovellusten testaamista sek‰ k‰yd‰‰n l‰pi ratkaisuja, joilla HTML5-sovelluksia voidaan paketoida helposti eri alustoja varten ja n‰in ollen saavuttaa samat edut BDD:ll‰ kuin natiivisovellusten kohdalla. T‰st‰ muodostetaan oma ratkaisunsa t‰ydent‰m‰‰n natiivisovellusten testaukseen lˆytyneit‰ ratkaisuja.

\chapter{Ketter‰ ohjelmistokehitys}

\section{Taustaa ja ketterien menetelmien kehitys}

Niin kauan kuin tietokoneohjelmistoja on kehitetty, on niiden yhteydess‰ kehitetty myˆs erilaisia malleja, joiden tarkoituksena on helpottaa ja sujuvoittaa ohjelmistokehityst‰. Menetelm‰t voidaan karkeasti jakaa inkrementaalisiin ja iteratiivisiin menetelmiin \cite{iterative}. Inkrementaalisissa malleissa ideana on se, ett‰ ohjelmisto kasvaa jatkuvasti kehittyen kohti lopullista valmista tuotetta, kun taas iteratiivisissa malleissa ohjelmistoa kehitet‰‰n pieniss‰ osissa lyhyemill‰ aikav‰leill‰ ja t‰t‰ tyˆt‰ toistetaan useaan otteeseen. Seuraavassa esitell‰‰nkin muutamia tunnettuja ohjelmistotuotannon malleja ja niiden kehityst‰ kohti ketteri‰ menetelmi‰.

\subsection{Vesiputousmalli}

Yksi varhaisista ohjelmistokehityksen malleista on inkrementaalinen vesiputousmalli, jonka perustana toimii hyvin pitk‰lti Winston Roycen kuvaama malli artikkelissaan Managing the development of large software systems \cite{managing} vuodelta 1970. Huolimatta siit‰, ett‰ vesiputousmalli on eritt‰in vanha ja sen k‰ytt‰minen sis‰lt‰‰ tunnettuja riskej‰, on malli edelleen hyvin suosittu. Roycen malli perustuu ajatukselle, ett‰ kaikissa ohjelmistokehitysteht‰viss‰ on aina ainakin kaksi vaihetta, analyysivaihe ja itse ohjelmiston koodausvaihe. Vesiputousmallissa luodaan t‰m‰n ajatuksen ymp‰rille laajempi malli, jossa edell‰mainittuja vaiheita on t‰ydennetty uusilla vaiheilla, jotka ovat kuitenkin t‰ysin erillisi‰ analyysi- ja koodausvaiheista. N‰it‰ ovat Roycen mallissa \cite{managing} kaksi vaatimusm‰‰rittelyvaihetta, ohjelmiston suunnittelu ja koodauksen j‰lkeinen testausvaihe. N‰ill‰ lis‰yksill‰ malli on soveltuvampi suurten ohjelmistoprojektien l‰pivientiin. Roycen esitt‰m‰ malli ei kuitenkaan ole t‰ysin se vesiputousmalli, joka on viel‰ nyky‰‰nkin k‰ytˆss‰, sill‰ Royce itsekin ehdottaa parhaimpana versiona mallistaan sellaista, jossa eri vaiheiden v‰lill‰ voidaan liikkua kumpaankin suuntaan, eli myˆs takaisinp‰in edellseen vaiheeseen.

Royce kuitenkin tiedostaa vesiputousmallin sis‰lt‰mi‰ riskej‰ jo omassa artikkelissaan. Yksi n‰ist‰ on esimerkiksi vaara, ett‰ vasta testivaiheessa huomataan puutteita, jotka johtavat perinpohjaisiin muutoksiin ohjelmiston rakenteessa tai toiminnassa, jolloin k‰yt‰nnˆss‰ koko kehitysprosessi joudutaan aloittamaan alusta. N‰it‰ puutteita voi suurellakin todenn‰kˆisyydell‰ ilmet‰, sill‰ testausvaihe on ensimm‰inen kerta, kun j‰rjestelm‰ toimii kokonaisuutena integroituna muihin j‰rjestelmiin \cite{managing}. Toinen merkitt‰v‰ tekij‰, joka monesti j‰tet‰‰n huomioimatta vesiputousmallia k‰ytett‰ess‰, on se, ett‰ Royce itsekin suosittelee k‰ym‰‰n prosessin l‰pi kahteen kertaan. T‰m‰ p‰tee etenkin tilanteisiin, jossa toimitetaan asiakkaalle jokin t‰ysin uusi tuote. T‰llˆin ensimm‰isell‰ kerralla luodaan pilotti tuotteesta lyhyess‰ ajassa. T‰m‰n pilotin tarkoituksena on tuoda esiin kehitett‰v‰n tuotteen erityiset haasteet, lˆyt‰‰ suunnittelun mahdolliset puutteet sek‰ luoda eri vaihtoehtoja n‰iden ratkaisemiseen \cite{managing}. T‰llˆin lyhyess‰ ajassa kehitetty pilottituote toimii ik‰‰n kuin koko projektin simulaationa, jolloin vaikeisiin tilanteisiin osataan varautua paremmin.

Royce ei itsek‰‰n pit‰nyt malliaan parhaana mahdollisena suurten ohjelmistojen kehitykseen, vaan Larmanin ja Basilin artikkelissa \cite{iterative} kerrotaankin, kuinka h‰n itsekin toteaa vesiputousmallin olevan kaikista yksinkertaisin malli, joka ei kuitenkaan todenn‰kˆisesti tule toimimaan kuin kaikkein yksinkertaisimpien ja suoraviivaisimpien projektien yhteydess‰. Ensimm‰iset maininnat ja kehotukset iteratiiviseen ohjelmistokehitykseen ovatkin jo ajalta ennen Roycen mallin julkaisua. Jo vuonna 1969 IBM:n tutkimuskeskuksessa M.M Lehman kuvasi iteratiivista mallia, jossa erotettiin suunnittelu, arviointi ja dokumentointi \cite{iterative}. T‰ss‰ mallissa suunnittelu tuotti jo toimivan mallin, jota sitten iteratiivisesti kehitettiin eteenp‰in.

Kuitenkin viel‰ nykyp‰iv‰n‰kin suuriakin ohjelmistoprojekteja toteutetaan k‰ytt‰en vesiputousmallia, sill‰ sen koetaan sis‰lt‰v‰n joitain etuja tietyiss‰ ohjelmistoprojektin vaiheissa verrattuna ketteriin menetelmiin. Monesti n‰m‰ ratkaisevat edut liittyv‰t erityisesti projektien myyntiin tarjousvaiheessa tehtyjen tarjousten muotoiluun. Vesiputousmallilla myyt‰viss‰ ratkaisuissa on helpompaa myyd‰ asiakkaalle kiinte‰ll‰ hinnalla yksi tarkasti m‰‰ritelty kokonaisuus, jonka myˆt‰ asiakas kokee tiet‰v‰ns‰ tarkalleen, millaisen tuotteen h‰n on saamassa ja mihin hintaan. Ketteri‰ projekteja myyt‰ess‰ asiakas k‰yt‰nnˆss‰ ostaa vain tyˆt‰, eik‰ kiinte‰sti m‰‰ritetty‰ lopputulosta \cite{valtiokonttori}. T‰llˆin asiakkaalle j‰‰ jatkuvasti mahdollisuus vaikuttaa siihen, ett‰ tehty tyˆ on juuri sit‰, mist‰ h‰nelle on eniten hyˆty‰, eik‰ ohjelmistoon toteuteta esimerkiksi t‰ysin turhia tai vanhentuneita vaatimuksia. Kuitenkin t‰st‰ huolimatta monesti ainoastaan lopullinen kiinte‰ hinta ja myyntivaiheessa m‰‰ritelty lopputulos ratkaisevat ostop‰‰tˆst‰ tehdess‰, jolloin edelleen nyky‰‰n saatetaan p‰‰ty‰ toteuttamaan projekteja vesiputousmallia k‰ytt‰en.

\begin{figure}
\centering
\includegraphics[width=0.95\textwidth]{waterfall.eps}
\caption{Vesiputousmalli \cite{managing}}
\end{figure}

\subsection{Spiraalimalli}

Spiraalimalli on Barry Boehmin kehitt‰m‰ \cite{spiral} malli vuodelta 1986, joka on ensimm‰isi‰ tunnettuja iteratiivisia malleja ohjelmistokehityksess‰. Spiraalimallin t‰rkeimp‰n‰ ajatuksena on se, ett‰ siin‰ otetaan riskit entist‰ paremmin huomioon verrattuna esimerkiksi perinteiseen vesiputousmalliin. Spiraalimallissa jokainen iteraatio sis‰lt‰‰ nelj‰ merkitt‰v‰‰ osaa, jotka ovat \cite{spiral}:
\begin{enumerate}
\item Iteraation tavoitteiden, vaihtoehtojen ja rajoitteiden m‰‰rittely
\item Eri vaihtoehtojen arviointi sek‰ riskien tunnistaminen ja arviointi
\item Kehitystyˆ ja seuraavan tason tuotteen m‰‰rittely
\item Seuraavan iteraation suunnittelu
\end{enumerate}

\begin{figure}
\centering
\includegraphics[width=0.95\textwidth]{spiral.eps}
\caption{Spiraalimalli \cite{managing}}
\end{figure}

Mallissa jokaisessa iteraatiossa toteutetaan riskianalyysin j‰lkeen prototyyppimalli, josta sitten l‰hdet‰‰n kehitt‰m‰‰n valmista tuotetta, aivan kuten Roycen \cite{managing} ehdottamassa pilottituotemallissa. Lis‰ksi spiraalimallissa merkitt‰v‰‰ on se, ett‰ jokainen iteraatiokierros sill‰ hetkell‰ valmiina olevan tuotteen arviointiin, johon osallistuvat kaikki t‰rkeimm‰t henkilˆt, jotka tulevat k‰ytt‰m‰‰n tuotetta \cite{spiral}. Boehmin malli toimiikin pohjana hyvin monille nykyisille ketterille menetelmille, joissa hyˆdynnet‰‰n samankaltaisia iteraatioita. Esimerkiksi seuraavana k‰sitelt‰v‰ss‰ Scrumissa sprintit vastaavat hyvin pitk‰lle spiraalimallin iteraatioita, eli Scrum k‰yt‰nnˆss‰ sis‰lt‰‰ spiraalimallin prosessit, joiden p‰‰lle on viel‰ vain lis‰tty muuta.

Spiraalimallissa k‰ytet‰‰n eritt‰in paljon riski‰ m‰‰ritt‰m‰‰n teht‰vi‰ asioita. Boehmin mukaan \cite{spiral} esimerkiksi eri tyˆvaiheisiin k‰ytett‰v‰ aika m‰‰r‰ytyy sen perusteella, miten ne vaikuttavat olemassaolevaan riskiin. Jos esimerkiksi testaukseen k‰ytetty aika pienent‰‰ projektin kokonaisriski‰, siihen kannattaa k‰ytt‰‰ aikaa mieluummin kuin esimerkiksi uuden sovelluskehyksen k‰yttˆˆn vanhan tutun sovelluskehyksen sijaan, sill‰ t‰llainen valinta vain lis‰isi projektin riski‰ ja ep‰onnistumisen mahdollisuutta. T‰m‰n lis‰ksi Boehmin mukaan projektiryhm‰ k‰ytt‰‰ riskin arviointia siihen, kuinka yksityiskohtaisella tasolla asioita kannattaa projektissa tehd‰ \cite{spiral}. Esimerkiksi projektin dokumentointi voisi olla yksi osa-alue, johon t‰t‰ voidaan soveltaa. Projektiryhm‰n tulee t‰llˆin tehd‰ p‰‰tˆs, milloin projektin dokumentaatio on riitt‰v‰ll‰ tasolla siten, ett‰ sen tarkentamisesta ja edelleen kehitt‰misest‰ ei saada en‰‰ mit‰‰n hyˆty‰, vaan se voi johtaa vain kasvavaan riskiin, kuten esimerkiksi julkaisun myˆh‰stymiseen.

Uudemmassa julkaisussaan vuodelta 2000 Boehm \cite{spiral2} viel‰ erikseen listaa merkkej‰, jotka erottavat projektin spiraalimallista ja ovat ennenkaikkea haitallisia projektin onnistumisen edellytyksille. K‰yt‰nnˆss‰ n‰m‰ merkit ovat sellaisia, joista voidaan huomata k‰ytett‰v‰n oikeasti vesiputousmallia, jota vain nimitet‰‰n spiraalimalliksi. T‰llaisia merkkej‰ ovat Boehmin mukaan seuraavat kuusi olettamusta \cite{spiral2}:
\begin{enumerate}
\item Vaatimukset tunnetaan ennen ohjelmiston toteutusta
\item Vaatimuksissa ei ole ep‰selvi‰ olettamuksia
\item Vaatimusten luonne ei muutu kehitystyˆn ja projektin etenemisen myˆt‰
\item Vaatimukset t‰ytt‰v‰t kaikkien sidosryhmien edustajien oletukset
\item Oikea arkkitehtuuri vaatimusten t‰ytt‰miseen on hyvin ymm‰rretty ja omaksuttu
\item Tarpeeksi kalenteriaikaa on varattu, jotta voidaan edet‰ per‰kk‰isess‰ j‰rjestyksess‰ vaihe kerrallaan
\end{enumerate}

Boehm m‰‰rittelee myˆs erilaisia invariantteja, jotka tulee olla olemassa spiraalimallin toimimisen edellytyksen‰ \cite{spiral2}. N‰m‰ invariantit k‰yt‰nnˆss‰ m‰‰rittelev‰t vain tarkemmin spiraalimallin eri osa-alueet ja niiden sis‰llˆt. N‰ihin Boehmin invariantteihin kuuluu esimerkiksi edell‰mainitut k‰ytett‰v‰n panoksen m‰‰rittely riskin perusteella sek‰ tyˆvaiheen toteutuksen yksityiskohtaisuuden tason arviointi riskin perusteella. N‰iden lis‰ksi Boehmin m‰‰rittelemiin invariantteihin lasketaan myˆs keskittyminen j‰rjestelm‰‰n ja sen elinkaareen sen sijaan, ett‰ ainoastaan mietitt‰isiin ohjelmiston kehitt‰mist‰ teknisest‰ n‰kˆkulmasta \cite{spiral2}.

\subsection{Scrum}

Scrum on moderni iteratiivinen ohjelmistokehityksen viitekehys, jota ovat kehitt‰neet p‰‰asiallisesti yhdysvaltalaiset Ken Schwaber ja Jeff Sutherland aina 1990-luvun alkupuolelta l‰htien. Kuten termi viitekehys antaa ymm‰rt‰‰, ei Scrum tarjoa mit‰‰n yksityiskohtaista prosessia ohjelmistoprojektin toteuttamiseen, vaan ennemminkin juuri kehyksen, jonka puitteissa voidaan hallita monimutkaisten tuotteiden kehityst‰ \cite{scrumguide}. Scrum tarjoaa k‰yt‰nnˆn tyˆkalut ohjelmistojen kehitt‰miseen iteratiivisesti siten, ett‰ riski on jatkuvasti mahdollisimman pieni ja tyˆn tulokset optimoituja, eli k‰yt‰nnˆss‰ tehd‰‰n aina sit‰, mik‰ on juuri sill‰ hetkell‰ asiakkaalle kaikkein hyˆdyllisint‰. T‰m‰ saavutetaan, kun tyˆskennell‰‰n nojautuen Scrumin kolmeen l‰htˆkohtaan, jotka ovat l‰pin‰kyvyys, tarkastelu ja sopeutuminen \cite{scrumguide}.

L‰pin‰kyvyys tulee Scrumissa ilmi erityisesti esimerkiksi siin‰, ett‰ kaikki eri sidosryhm‰t ovat jatkuvasti tietoisia toteutettavan projektin tilanteesta. K‰yt‰nnˆn tyˆss‰ t‰m‰ on toteutettu monin eri tavoin \cite{scrumguide}:

\begin{itemize}
\item Tyˆt‰ suoritetaan kiinte‰n pituisissa jaksoissa, joita kutsutaan sprinteiksi. Usein sprinttien kesto on yhdest‰ kolmeen viikkoa. N‰ihin sprintteihin projektitiimi ottaa mukaan tyˆt‰ niin paljon kuin he arvioivat kykenev‰ns‰ toteuttamaan. T‰ss‰ kohtaa ainoastaan projektitiimi voi m‰‰ritell‰ mit‰ he tekev‰t, sill‰ heill‰ on ainoina henkilˆin‰ tieto siit‰, mit‰ he tiimin‰ pystyv‰t toteuttamaan. T‰m‰ sprintiin otettu tyˆ muodostaa sprintin backlogin, johon voidaan sprintin suunnittelun j‰lkeen ainoastaan projektitiimin luvalla ottaa lis‰‰ tyˆt‰. T‰llˆin asiakas ja projektin muut sidosryhm‰t tiet‰v‰t aina mit‰ seuraavan sprintin aikana on tarkoituksena saada toteutetuksi \cite{scrumguide}.
\item Koko projektin seurantaan ja l‰pin‰kyvyyteen Scrumissa on olemassa tuotteen backlog, joka sis‰lt‰‰ kaikki tulevaisuudessa toteutettavaksi toivotut ominaisuudet ja teht‰v‰t asiakkaan puolelta. T‰t‰ tuotebacklogia asiakas priorisoi yhdess‰ Scrum-tiimiin kuuluvan tuoteomistajan kanssa. T‰m‰ tarkoittaa sit‰, ett‰ backlogilla nostetaan prioriteetiltaan t‰rkeimm‰t teht‰v‰t ensimm‰isiksi. T‰m‰ on t‰rke‰‰, sill‰ projektitiimi ottaa sitten tuotebacklogilta jokaiseen sprintiin niin paljon tyˆt‰ kuin he kokevat pystyv‰ns‰ tekem‰‰n. Tyˆt‰ otetaan tuotebacklogilta mukaan sprintiin siin‰ j‰rjestyksess‰, mihin asiakas on teht‰v‰t yhdess‰ tuoteomistajan kanssa priorisoinut.
\item Projektissa toteutettavan tuotteen tila on koko ajan selvill‰ kaikille sidosryhmille, sill‰ Scrumissa on tavoitteena, ett‰ jokaisen valmiin sprintin j‰lkeen projektiryhm‰ voisi toimittaa asiakkaalle k‰yt‰nnˆss‰ toimivan inkrementin toteutettavaan ohjelmistoon, jolloin jokaisen sprintin tyˆn tulos olisi heti n‰ht‰vill‰. K‰yt‰nnˆss‰ toimivan inkrementin toimitus ei kuitenkaan aina ole esimerkiksi projektin luonteen vuoksi mahdollista, jos toteutettavana tuotteena on jokin laaja tietoj‰rjestelm‰, jossa k‰ytet‰‰n useita sprinttej‰ esimerkiksi pelk‰st‰‰n back endin tai tietokantojen toteuttamiseen. T‰llˆin inkrementti voi olla kuitenkin toimiva, vaikkei asiakas siit‰ heti suoraa hyˆty‰ saisikaan.
\end{itemize}

Tehty‰ tyˆt‰, tyˆtapoja ja projektia kokonaisuudessa arvioidaan ja tarkastellaan Scrumin puitteissa jatkuvasti. Erityist‰ t‰ss‰ on se, ett‰ n‰it‰ asioita ei ole arvioimassa vain yksi taho, vaan tyˆn ja tulosten tarkastelua tehd‰‰n jatkuvasti kaikkien toimesta, jotka liittyv‰t projektiin mill‰‰n tapaa.

P‰ivitt‰in tyˆt‰ arvioidaan ns. daily-palavereissa, joissa jokainen projektitiimin j‰sen p‰‰see kertomaan mit‰ on tehnyt, mit‰ aikoo tehd‰ ja samalla h‰n voi kertoa, jos tyˆss‰ on ilmennyt jotain ongelmia. T‰llaisen lyhyen kiinte‰sti 15-minuuttiseksi ajoitetun palaverin myˆt‰ koko tiimi on joka p‰iv‰ selvill‰ siit‰, mit‰ muut tekev‰t ja mahdollisesti pystyv‰t n‰in ollen esimerkiksi auttamaan muita ja tehostamaan omaa tyˆt‰‰n sill‰, etteiv‰t he tee p‰‰llekk‰isi‰ tai toisistaan riippuvia teht‰vi‰.

Jokaisen sprintin p‰‰ttyess‰ j‰rjestet‰‰n niin kutsuttu sprintin arviointi, jossa projektitiimi yhdess‰ asiakkaan kanssa k‰y product ownerin johdolla l‰pi sprintin aikana toteutettuja ominaisuuksia ja teht‰vi‰. Samassa tilaisuudessa k‰yd‰‰n l‰pi ne sprintiin mukaan otetut tyˆt, joita projektitiimi ei ole ehtinyt saada valmiiksi. Sprintin arviointi onkin hyv‰ tilaisuus sek‰ projektitiimille, ett‰ asiakkaalle, sill‰ t‰llˆin kummatkin p‰‰sev‰t yhdess‰ keskustelemaan siit‰, mit‰ tiimi on tehnyt. T‰llˆin asiakkaalla on mahdollisuus esitt‰‰ kysymyksi‰ ja toteuttava tiimi p‰‰see myˆs kertomaan mahdollisista ongelmista ja niiden ratkaisuista, eli tilaisuudessa pystyt‰‰n viimeist‰‰n oikomaan mahdollisia v‰‰rink‰sityksi‰ tai n‰kemyseroja.

Daily-palaverien ja sprintin arvioinnin lis‰ksi projektitiimi k‰y jokaisen sprintin j‰lkeen l‰pi retrospektiivin, jossa jokaisella tiimin j‰senell‰ on mahdollisuus arvioida, mik‰ tiimin tyˆss‰ meni hyvin ja mill‰ alueilla on viel‰ kehitett‰v‰‰. N‰m‰ onnistumiset liittyv‰t yleens‰ ennemminkin tiimin sis‰isiin asioihin kuin mihink‰‰n muuhun, eli ennenkaikkea asioihin, joihin tiimi itse voi vaikuttaa. T‰llaisia asioita ovat esimerkiksi:
\begin{itemize}
\item Kuinka hyvin Scrumin periaatteita on noudatettu?
\item Onko tiimin sis‰isess‰ dynamiikassa jotain ongelmia?
\item Voisiko tyˆtapoja parantaa jotenkin?
\item Onko jotain projektiin liittym‰ttˆmi‰ ongelmia, jotka haittaavat tyˆt‰?
\end{itemize}

\begin{figure}
\centering
\includegraphics[width=0.95\textwidth]{scrum.eps}
\caption{Scrum \cite{scrumkuva}}
\end{figure}

Kolmas Scrumin perusperiaate, eli sopeutuminen, tulee myˆs esille monissa eri yhteyksiss‰ ja toimintatavoissa. Edell‰mainituissa daily-palavereissa yksi t‰rke‰ asia on se, ett‰ kaikki projektitiimin j‰senet p‰‰sev‰t kertomaan mahdollisista ongelmistaan, joita ovat tyˆss‰‰n kohdanneet. T‰llˆin tiimill‰ on mahdollisuus puuttua n‰ihin ongelmiin heti ja ratkaista ne yhdess‰ sen sijaan, ett‰ tiimin j‰sen j‰isi yksin ongelmiensa kanssa ja tˆiden eteneminen mahdollisesti hidastuisi, jolloin myˆsk‰‰n sprintin tavoite ei v‰ltt‰m‰tt‰ t‰yttyisi. 

Jokaisen sprintin p‰‰tteeksi l‰pik‰yt‰v‰ retrospektiivi on tyˆn ja tyˆtapojen tarkastelun ohella eritt‰in hyv‰ tilaisuus tiimille sopeutumiseen, sill‰ tilaisuudessa ei ole tarkoitus tuoda esiin vain huonoja toimintatapoja tai ongelmia, vaan ennenkaikkea n‰ihin esille tuleviin kehityskohteisiin yritet‰‰n koko tiimin voimin lˆyt‰‰ ratkaisuja heti \cite{msretro}. T‰llˆin ongelmat eiv‰t j‰‰ kenenellek‰‰n yksin hoidettaviksi, vaan niihin voidaan heti puuttua useamman henkilˆn voimin. Myˆs toisessa sprintin p‰‰tteeksi l‰pik‰yt‰v‰ss‰ tapahtumassa, eli sprintin arvioinnissa, on eri sidosryhmill‰ hyv‰t mahdollisuudet sopeutumiseen. T‰ss‰ tilaisuudessa tilaisuudessa asiakas voi antaa palautetta kehitystiimin suuntaan, kuten myˆs toisinp‰in. T‰llˆin esimerkiksi kehitystiimi voi ottaa oppia, jos vaikkapa joitain asiakkaan pyyntˆj‰ on ymm‰rretty v‰‰rin ja vastaavasti asiakas voi saada hyv‰‰ kokemusta siit‰, mill‰ tavalla asiat kannattaa kehitystiimille esitt‰‰.

Ylip‰‰ns‰ Scrumin sprinttiajattelu tarjoaa jatkuvaan sopeutumiseen eritt‰in hyv‰t mahdollisuudet. Kun k‰yt‰nnˆn tyˆss‰ tyˆn alle otettavat teht‰v‰t lukitaan vain yhdeksi sprintiksi kerrallaan, tiimin on helppo sopeutua muuttuviin vaatimuksiin ja asiakkaan toiveisiin. Esimerkiksi asiakkaalle t‰rke‰ uusi ominaisuus voidaan ottaa heti seuraavassa alkavassa sprintiss‰ tyˆn alle, jos sen prioriteetti on niin t‰rke‰, ett‰ se menee muiden tuotteen backlogin teht‰vien edelle. Muutenkin sprintit tarjoavat tiimille mahdollisuuden muuttua tarpeen mukaan nopeasti. Tiimin kokoa voidaan helposti tarpeen mukaan muokata, uusia toimintatapoja k‰yd‰ retrospektiiveiss‰ l‰pi sek‰ suuriakin suunnanmuutoksia projektissa voidaan tehd‰ helposti verrattuna esimerkiksi vanhaan vesiputousmalliin.

Edell‰mainittujen tilaisuuksien ohella Scrum-tiimiss‰ on m‰‰ritelty henkilˆ, joka mahdollistaa tiimin sopeutumista. T‰lle henkilˆll‰ on Scrum-tiimiss‰ oma erityinen roolinsa, aivan kuten tuoteomistajalla ja kehitystiimin j‰senell‰. T‰t‰ kutsutaan scrummasteriksi, jonka teht‰v‰n‰ on toimia palvelevana johtajana. K‰yt‰nnˆn tasolla t‰m‰ tarkoittaa sit‰, yksi kehitystiimin j‰senist‰ toimii mahdollisten omien teht‰viens‰ ohella scrummasterin roolissa tai mahdollisesti h‰nell‰ ei ole mit‰‰n muita teht‰vi‰ kuin scrummasterin teht‰v‰t. Scrummasterin teht‰v‰n‰ on toimia kehitystiimille mahdollistajana, eli h‰n ratkaisee kehitystiimin puolesta sellaisia ongelmia, joita esimerkiksi daily-palavereissa tulee esille, jotka haittaavat heid‰n tyˆntekoaan. Scrummasterin teht‰v‰n‰ on myˆs valvoa, ett‰ Scrumin k‰yt‰nteit‰ toteutetaan ja niist‰ pidet‰‰n kiinni. T‰m‰ tarkoittaa sit‰, ett‰ scrummaster toimii fasilitaattorina, eli pit‰‰ huolen siit‰, ett‰ esimerkiksi daily-palaverit pidet‰‰n, sprintien suunnittelut pidet‰‰n ja kaikista m‰‰r‰tyist‰ aikam‰‰reist‰ pidet‰‰n kiinni. Scrummasterin teht‰v‰n‰ on huolehtia n‰ille tapahtumille paikat, joissa ne voidaan j‰rjest‰‰. H‰n myˆs toimii yhteydenpit‰j‰n‰ kehitystiimin ja muiden sidosryhmien v‰lill‰ siten, ett‰ itse kehitystiimin j‰senten tyˆ ei h‰iriinny turhaan. T‰ten scrummaster voi esimerkiksi selitt‰‰ Scrumin periaatteita muille sidosryhmille, jotta p‰‰st‰isiin mahdollisimman hyv‰‰n ymm‰rrykseen siit‰, miksi asioita tulee tehd‰ Scrumin toimintaperiaatteiden mukaan, jolloin kehitystiimin ei tarvitse huolehtia t‰m‰nkaltaisten asioiden selitt‰misest‰ muille tahoille.

\section{Laatu}

Tietokoneohjelmistojen laadun merkitys on jatkuvasti yh‰ suuremmassa roolissa, kun monet yhteiskunnan t‰rkeist‰ toiminnoista digitalisoituvat. T‰m‰ tarkoittaa myˆs sit‰, ett‰ yh‰ suuremmassa m‰‰rin yhteiskunnan toiminnan kannalta kriittiset palvelut nojaavat ohjelmistojen toimintavarmuuteen. T‰m‰ sama ilmiˆ on tapahtunut myˆs teollisuudessa, eik‰ nykyp‰iv‰n‰ oikeastaan ole mit‰‰n alaa, jossa tietotekniikka ei tarvittaisi. Laadunvarmistus ja suhtautuminen laadun k‰sitteeseen poikkeaa hyvin paljon vaiheellisissa ohjelmistotuotantoprosesseissa verrattuna iteratiivisesti toimiviin prosesseihin. Seuraavassa k‰sitell‰‰nkin n‰iden erityispiirteit‰ ja eroavaisuuksia.

\subsection{Laatu vaiheellisissa ohjelmistotuotantoprosesseissa}

Vaiheellisissa ohjelmistotuotantoprosesseissa, kuten esimerkiksi vesiputousmallissa, testaus ja laadunvarmistus on erotettu omaksi erilliseksi vaiheekseen, joka tapahtuu vasta toteutusvaiheen j‰lkeen \cite{managing}. T‰llˆin tilanne on se, ett‰ koko projekti on toteutettu valmiiksi asti kiinteill‰ muuttumattomilla vaatimuksilla, jotka on lukittu ennen toteutustyˆn aloittamista. Testausvaiheessa toteutettua ohjelmisto testataan n‰it‰ vaatimuksia vasten, eli pidet‰‰n huolta, ett‰ n‰m‰ vaatimukset t‰yttyv‰t. 

Monesti ongelmallista onkin, ett‰ asiakas saa toimivan tuotteen vasta t‰m‰n testausvaiheen j‰lkeen ensimm‰ist‰ kertaa itselleen testattavaksi, jolloin kyseess‰ on mahdollisesti alkuper‰isten vaatimusten mukaisesti toimiva tuote, mutta k‰yt‰nnˆss‰ asiakkaan n‰kemys ja tarve on voinut muuttua jo monilta osin sin‰ aikana, kun ohjelmisto on toteutettu. N‰in ollen valmiin tuotteen laatu voikin olla asiakkaan mielest‰ huonompi kuin projektin toteuttajien n‰kemys on. Kuitenkin teknisell‰ tasolla vaiheellisissa prosesseissa voidaan panostaa laatuun aivan samalla tapaa kuin iteratiivisissakin prosesseissa. Implementaatiota tehdess‰ yksikkˆtestauksen merkitys laadunvarmistuksessa on aivan yht‰ suuri kuin iteratiivisissakin prosesseissa.

Kaikenkaikkiaan vaiheellisissa ohjelmistotuotantoprosesseissa testaukseen ja laadunvarmistukseen on hyv‰t ja kehittyneet keinot, sill‰ t‰m‰ osa-alue on aina ollut mukana omana vaiheenaan prosesseissa \cite{agilequality}. Ongelmaksi n‰iss‰ prosesseissa laadun kohdalla muodostuukin l‰hinn‰ eri osapuolten k‰sitys laadusta ja mahdolliset asiakkaan muuttuneet tarpeet.

\subsection{Laatu iteratiivisissa ohjelmistotuotantoprosesseissa}

Iteratiivisista ohjelmistotuotantoprosesseista t‰ss‰ keskityt‰‰n erityisesti Scrumiin ja sen suhtautumiseen laatuun. Iteratiivisissa prosesseissa jokaisen sprintin voidaan ajatella toimivan ik‰‰nkuin samalla tavoin kuin kokonaisen vesiputousmallin projektin kaikki vaiheet, sprintin sis‰lt‰ ei kuitenkaan v‰ltt‰m‰tt‰ voida selv‰sti n‰it‰ vaiheita erottaa \cite{agilequality}. Kuitenkin toteutustyˆss‰ t‰rkeit‰ laadunvarmistuksen v‰lineit‰ ovat esimerkiksi yksikkˆtestit, joita k‰ytet‰‰n aivan samalla tavoin kuin vaiheellisissa prosesseissa. Erona vaiheellisiin prosesseihin, iteratiivisissa prosesseissa testaus tehd‰‰n pohjautuen sprintiin valittuihin teht‰viin, joka tarkoittaa sit‰, ett‰ sprintiin valituille tˆille on m‰‰ritetty hyv‰ksymiskriteerit, joissa m‰‰ritell‰‰n milloin haluttu ominaisuus on valmis. Sprintin aikana valmistuvia teht‰vi‰ testataan sitten asetettuja hyv‰ksymiskriteerej‰ vasten, jotka m‰‰ritell‰‰n yhdess‰ asiakkaan kanssa.

Sprinteiss‰ tapahtuvan testauksen ja laadunvarmistuksen ohella Software Quality and Methods -julkaisu \cite{agilequality} listaa muutamia muita iteratiivisissa ohjelmistotuotantoprosesseissa yleisesti k‰ytˆss‰ olevia toimintatapoja, joiden voidaan katsoa parantavan ohjelmiston laatua:
\begin{itemize}
\item Jatkuvalla integraatiolla tarkoitetaan k‰yt‰ntˆ‰, jossa ohjelmistoon tehtyj‰ muutoksia integroidaan jatkuvasti ja muutosten myˆt‰ automaattisesti testataan ohjelmiston toiminta ja integraatiot \cite{ci}. T‰llaisella k‰yt‰nnˆll‰ kehitystiimill‰ on jatkuvasti toimiva ohjelmisto, ja kehitystiimi p‰‰see eroon suuresta riskist‰, joka syntyy, kun suuri m‰‰r‰ muutoksia ohjelmistoon otetaan k‰yttˆˆn samaan aikaan. Kun tehdyt muutokset integroidaan heti valmistumisen j‰lkeen muuhun j‰rjestelm‰‰n, voidaan mahdollisiin virheisiin tai suurempiin ongelmiin puuttua heti. 
\item Jatkuvan integraation palvelimet, kuten esimerkiksi yksi suosituimmista avoimeen l‰hdekoodiin perustuviasta ratkaisuista, Jenkins \cite{jenkins}, toimivat jatkuvan integraation mahdollistajina. K‰yt‰nnˆss‰ n‰m‰ palvelimet aina versiohallinnassa tapahtuvien muutosten yhteydess‰ buildaavat sovelluksen automaattisesti, ajavat sille kirjoitetut testit ja ottavat sen mahdollisesti k‰yttˆˆn sovelluspalvelimella. Jatkuvan integraation palvelimet antavat siten heti viestin, mik‰li ohjelmiston buildaaminen ei onnistu tai testeiss‰ on virheit‰, jolloin kehitt‰j‰t tiet‰v‰t virheist‰ l‰hes heti commitin j‰lkeen \cite{ci}.
\item Usein iteratiivisissa prosesseissa, kuten Scrumissa, on kommunikaatiolla ja yhdess‰ asiakkaan kanssa tyˆskentelyll‰ t‰rke‰ rooli, jonka voidaan n‰hd‰ parantavan ohjelmiston laatua. T‰ll‰ tavoin asiakkaaseen saadaan helposti yhteytt‰ ja h‰nen kanssaan voidaan jatkuvasti kommunikoida, mik‰ edist‰‰ esimerkiksi ep‰selvien vaatimusten selvityksess‰ ja niiden jatkuvaa parantamista \cite{agilequality}. Myˆs esimerkiksi Scrum-tiimin tuoteomistaja on usein asiakkaan edustaja, jolloin asiakkaalla on jatkuvasti todella hyv‰ n‰kyvyys siihen, mit‰ ollaan tekem‰ss‰, kun tuoteomistaja vastaa tuotebacklogin priorisoinnista. T‰llˆin asiakas voi varmistaa sen, ett‰ kehitystiimi tyˆskentelee jatkuvasti sellaisten tˆiden parissa, jotka ovat asiakkaalle kaikkein hyˆdyllisimpi‰. Tilanne, jossa tuoteomistaja on nimetty asiakkaan puolesta, on kommunikaatiomahdollisuuksiensa puolesta l‰hes ihanteellinen, sill‰ Scrumissa tuoteomistaja on henkilˆ, jolla tulisi olla jatkuvasti kaikkein paras visio siit‰, mit‰ ollaan tekem‰ss‰ ja mit‰ ohjelmistoon seuraavaksi halutaan tehd‰ \cite{scrumguide}.
\end{itemize}

Ketteriss‰ menetelmiss‰ kehitt‰jill‰ on enemm‰n vastuuta ohjelmiston laadusta kuin perinteisissa vaiheellisissa ohjelmistotuotantoprosesseissa. T‰m‰ ei tule varsinaisesti esille suoraan iteratiivisissa ohjelmistotuotantoprosesseissa, mutta t‰m‰ johtuu hyvin pitk‰lti siit‰, ett‰ n‰iss‰ prosesseissa pelk‰n suunnittelun m‰‰r‰ on usein minimoitu ja jonkinlaista toteutusta l‰hdet‰‰n tekem‰‰n l‰hes heti. T‰llˆin laadunvarmistusta joudutaan tekem‰‰n paljon jo kehitt‰jien toimesta ohjelmistoa implementoidessa \cite{agilequality}. Nopeisiin sykleihin, jatkuvaan integraatioon ja tuotteen toimituksiin on ohjelmistoalalla iteratiivisissa prosesseissa sopeuduttu ohjelmistokehityksen toimintatapoja on muokkaamalla siten, ett‰ ohjelmoinnissa k‰ytet‰‰n menetelmi‰, joiden voidaan katsoa edist‰v‰n laadunvarmistusta. Yksi t‰rkeist‰ laatua edist‰vist‰ ohjelmistokehityksen malleista on TDD, jota k‰sitell‰‰n seuraavassa.

\section{TDD}

TDD, eli Test-driven development, tarkoittaa testivetoista ohjelmistokehityst‰. TDD poikkeaa edell‰ esitetyist‰ malleista siin‰, ett‰ siin‰ miss‰ edell‰ esitellyt mallit kattavat koko ohjelmistokehitysprosessin, ottaa TDD kantaa ainoastaan edelt‰viss‰ malleissa esiintyneisiin k‰yt‰nnˆn toteutus- ja testausvaiheisiin. K‰yt‰nnˆss‰ siis nyky‰‰n ohjelmistoprojekteissa valitaan jokin koko ohjelmistokehitysprosessin kattava malli, kuten Scrum, jossa sitten hyˆdynnet‰‰n TDD:t‰ ja sen ohjelmointik‰yt‰nteit‰. Seuraavassa esitell‰‰nkin TDD:n keskeisimm‰t ideat ja toimintaperiaatteet, joita k‰yt‰nnˆn ohjelmistokehityksess‰ usein noudatetaan.

Yksinkertaistettuna testivetoisessa ohjelmistokehityksessa ideana on se, ett‰ testit kirjoitetaan ennen kuin kirjoitetaan rivi‰k‰‰n koodia. K‰yt‰nnˆss‰ t‰m‰ tarkoittaa sit‰, ett‰ ennen ohjelmointia testeill‰ m‰‰ritell‰‰n se, mit‰ seuraavaksi kirjoitettavan metodin olisi tarkoitus tehd‰. Tyˆvaiheet t‰ss‰ prosessissa ovat seuraavanlaiset \cite{tdd}:
\begin{itemize}
\item Kirjoitetaan testi, joka ei mene l‰pi.
\item Kirjoitetaan koodi, joka l‰p‰isee testin. T‰ss‰ vaiheessa ei ole vaatimuksia koodin optimoinnille tai laadulle.
\item Ajetaan testit ja todetaan niiden menev‰n l‰pi.
\item Refaktorointi. Refaktoroidaan kohdassa kaksi kirjoitettua koodia, eli esimerkiksi poistetaan siit‰ kaikenlaiset ep‰loogisuudet, siirret‰‰n metodi loogisesti oikeaan paikkaan ja nimet‰‰n se j‰rkev‰sti.
\item Aloitetaan prosessi alusta.
\end{itemize}

TDD:n voidaan katsoa edist‰v‰n tyˆskentely‰ ainakin nelj‰st‰ eri n‰kˆkulmasta \cite{tddeff}. Ensiksikin kehitt‰j‰ saa jatkuvaa palautetta tyˆst‰‰n viiveett‰. H‰n n‰kee heti toimiiko tekem‰ns‰ koodi oikein ja rikkooko se mahdollisesti muita toiminnallisuuksia ja niiden testej‰. T‰llˆin kehitt‰j‰ pystyy heti korjaamaan virheens‰, eik‰ niit‰ ehdi kasaantua kerralla paljoa.

Samalla t‰m‰ yhteen metodiin keskittyminen kerrallaan ohjaa ja jaksottaa kehitt‰j‰n tyˆskentely‰. T‰m‰ tarkoittaa sit‰, ett‰ kehitt‰j‰ keskittyy yhteen teht‰v‰‰n kerrallaan, kunnes saa valmiiksi toimivan testatun kokonaisuuden. T‰m‰n myˆt‰ kehitt‰jien on v‰ltt‰m‰tˆnt‰ myˆs pilkkoa tyˆt‰‰n pienempiin osiin siten, ett‰ t‰llainen teht‰v‰ kerrallaan l‰piviety kehitys on edes mahdollista \cite{tddeff}. Kun teht‰v‰t pilkotaan riitt‰v‰n pieniksi, kehitt‰jien on helpompi arvioida niihin kuluvaa aikaa, heill‰ on parempi k‰sitys siit‰, mit‰ jonkin asian valmistuminen viel‰ vaatii ja he kykenev‰t hallitsemaan omia tyˆn alla olevia tˆit‰‰n helpommin.

Kolmantena TDD tarjoaa omalta osaltaan yhden keinon laadunvarmistukseen. Kun ohjelmistoa kehitet‰‰n TDD:n keinoin, on jatkuvasti olemassa setti testej‰, jotka parhaassa tapauksessa kattavat koko ohjelmiston, jos se on alusta alkaen kehitetty TDD:ll‰ \cite{tddeff}. Sen lis‰ksi, ett‰ TDD:n myˆt‰ syntyv‰ testisetti on kattava, sit‰ myˆs ajetaan usein, sill‰ kaikkien uusien ominaisuuksien yhteydess‰ tulisi tarkistaa aina kaikkien testien toimivuus, jotta v‰ltyt‰‰n mahdollisilta uusien ominaisuuksien luomilta sivuvaikutuksilta.
 
Viimeiseksi TDD:ss‰ keskityt‰‰n ennen kaikkea matalalla tasolla koodin testaamiseen. Kun liikutaan yksitt‰isten metodien tasolla, on ohjelmoijalla usein hyv‰ n‰kemys siit‰, mit‰ kirjoitettavan metodin olisi tarkoitus tehd‰. T‰llˆin koodin laatu paranee ainakin t‰ll‰ matalalla tasolla, mutta TDD ei ota kantaa, eik‰ auta ohjelmoijaa ymm‰rt‰m‰‰n korkeamman tason toiminnallisia vaatimuksia tai suurempia kokonaisuuksia \cite{tdd}. T‰h‰n ongelmaan ratkaisuksi on l‰hivuosina kehitetty toimintatapoja, joilla pystyt‰‰n hallitsemaan paremmin edell‰mainittujen korkeamman tason vaatimusten t‰yttymist‰. N‰it‰ menetelmi‰ ovat muun muassa Acceptance Test-Driven Development (ATDD) sek‰ Behaviour-Driven Development (BDD), joita k‰sitell‰‰n tarkemmin j‰ljemp‰n‰.

Vuonna 2005 julkaistussa tutkimuksessa \cite{tddeff} suurimpana kysymyksen‰ oli selvitt‰‰ TDD:n vaikutusta tuottavuuteen. Tutkimuksessa todettiin testil‰htˆisen kehityksen todella lis‰‰v‰n kehitt‰jien tuottavuutta. T‰h‰n lˆydettiin tutkimuksessa \cite{tddeff} useita syit‰. Yksi n‰ist‰ oli jo edell‰kin mainittu teht‰vien pilkkominen ja sen myˆt‰ niihin keskittyminen. N‰ill‰ toimenpiteill‰ teht‰v‰t ovat helpommin ymm‰rrett‰vi‰ kokonaisuuksia, jotka voidaan helposti toteuttaa kerralla. Tutkimus myˆs toteaa \cite{tddeff}, ett‰ testivetoisessa kehityksess‰ huonot ja tehottomat toimintatavat hyl‰t‰‰n verrattain nopeasti ja ne korvataan paremmilla. Useimmissa prosessimalleissa t‰llaiset p‰‰tˆkset tekev‰t kehitt‰j‰t itse, eli n‰it‰ parannuksia ei osoiteta mist‰‰n ylemm‰lt‰ taholta. Esimerkiksi Scrumissa kehitystiimi itse k‰y jokaisen sprintin j‰lkeen retrospektiivissa l‰pi omaa toimintaansa ja yritt‰‰ lˆyt‰‰ siit‰ kehityskohteita \cite{scrumguide}. T‰m‰ jatkuva toimintatapojen tehostaminen johtaa myˆs nopeaan oppimiseen. TDD laskee myˆs kynnyst‰ asioiden uudelleen tekemiselle ja refaktoroinnille \cite{tddeff}. Kun ohjelmisto on toteutettu pienist‰ erikseen testatuista osista, on helppoa l‰hte‰ korjaamaan yht‰ hajonnutta testi‰, sill‰ hajoamisen syy on usein helppo lˆyt‰‰, kun testi kattaa vain yhden pienen osan ohjelmistosta, esimerkiksi yhden metodin, jonka teht‰v‰n pit‰isi olla helposti selitett‰v‰.

Kaikenkaikkiaan vuoden 2005 tutkimuksessa \cite{tddeff} p‰‰dyttiin tulokseen, jonka mukaan testivetoinen kehitys todellakin parantaa tyˆn tuottavuutta edell‰mainittujen seikkojen myˆt‰. Samalla tutkimuksessa kuitenkin todetaan, ett‰ testivetoinen ohjelmistokehitys ei suoranaisesti paranna ohjelmistojen laatua. T‰m‰ johtui siit‰, ett‰ vaikka ohjelmistokehitt‰j‰t kirjoivat TDD:t‰ k‰ytt‰ess‰‰n m‰‰r‰llisesti enemm‰n testej‰, testien laatu riippui hyvin paljon kehitt‰j‰n kokemuksesta tehd‰ tˆit‰ testivetoisesti \cite{tddeff}. Testivetoisessa kehityksess‰ testeill‰ osaltaan ohjataan kehitt‰j‰n tyˆt‰, eli kehitt‰j‰ kertoo testeill‰ itselleen mit‰ h‰nen pit‰isi seuraavaksi tehd‰. Taito kirjoittaa hyvi‰ testej‰, jotka testaavat oikeita asioita syntyy vain testej‰ kirjoittamalla, eli t‰ss‰ tilanteessa kokemus ja tyˆskentelytapaan tottuminen tuovat lis‰‰ tehokkuutta tyˆskentelyyn. Toisaalta myˆs matalan tason yksikkˆtesteist‰ saatavan hyˆdyn voitiin katsoa h‰vi‰v‰n siin‰, ett‰ kehitt‰j‰t pystyiv‰t monissa tilanteissa ohjelmaa tarkastelemalla helposti toteamaan saman asian kuin mit‰ yksikkˆtesti testaa \cite{tddeff}.

\begin{figure}
\centering
\includegraphics[width=0.95\textwidth]{tdd.eps}
\caption{TDD-tyˆvaiheet}
\end{figure}

\section{ATDD}
ATDD eli Acceptance Test-driven development tarkoittaa nimens‰ mukaisesti hyv‰ksymistestil‰htˆist‰ ohjelmistokehityst‰. ATDD:ss‰ kehitt‰j‰t, k‰ytt‰j‰t ja testaajat yhdess‰ m‰‰rittelev‰t ohjelmistolle hyv‰ksymiskriteerit, joiden pohjalta ohjelmistoa l‰hdet‰‰n kehitt‰m‰‰n \cite{difference}.  

ATDD:ll‰ ja BDD:ll‰ tarkoitetaan useissa yhteyksiss‰ samaa asiaa, sill‰ termit ovat alalla viel‰ niin uusia, eik‰ vakiintuneita k‰yt‰ntˆj‰ ole. T‰m‰n myˆt‰ termistˆ ja nimet muuttuvat jatkuvasti kehityksen myˆt‰. Hyvin pitk‰lti ATDD:n ja BDD:n ero voidaan n‰hd‰ lˆytyv‰n ennemminkin siin‰, mink‰ tasoiseen testaamiseen niiss‰ keskityt‰‰n \cite{difference}. Toinen tasoista on ATDD:n hyv‰ksymistestil‰htˆinen malli, jossa keskityt‰‰n automaattisiin hyv‰ksymistesteihin, joilla m‰‰ritell‰‰n selvi‰ vaatimuksia kehitt‰j‰tiimille, jotka toteutetun j‰rjestelm‰n tulee t‰ytt‰‰ \cite{specification}.

BDD sen sijaan toimii tasolla, jossa m‰‰ritell‰‰n erilaisia skenaarioita, joiden tavalla j‰rjestelm‰n tulisi toimia. BDD:n mallissa keskeist‰ on ennenkaikkea luoda ymm‰rryst‰ kehitt‰jien ja muiden sidosryhmien, kuten esimerkiksi asiakkaan edustajien, v‰lille \cite{specification}. T‰m‰n ohella kuitenkin BDD auttaa myˆs v‰ltt‰m‰‰n toiminnallisia regressiobugeja aivan kuten ATDD:kin. Kummatkin tasoista toteuttavat kuitenkin myˆs osaltaan esimerkein m‰‰rittelyn periaatteita ja est‰v‰t toiminnallisia regressiobugeja syntym‰st‰. ATDD:n tason voidaan n‰hd‰ myˆs soveltuvan paremmin tietynlaisiin toimintaymp‰ristˆihin, kun taas BDD:n taso toimii toisaalla paremmin. Gojko Adzic kirjoittaa Specification by Example -kirjassaan \cite{specification} ATDD:n mallin olevan hyˆdyllisempi, jos ollaan toteuttamassa ohjelmistoa, jossa on useita laatuun liittyvi‰ haasteita. BDD:n tason taas voidaan n‰hd‰ sopivan paremmin tilanteeseen, jossa ei ole suurempia ongelmia ja BDD:t‰ voidaankin k‰ytt‰‰ l‰hinn‰ selitt‰m‰‰n asioita. 

Kumpikin malli kuitenkin tuottaa eritt‰in hyv‰‰ dokumentaatiota j‰rjestelm‰st‰ ilman erillist‰ panostusta sen tekemiseen, ja t‰m‰n voidaankin n‰hd‰ olevan yksi suurimmista eduista, joita saavutetaan k‰ytt‰m‰ll‰ ATDD:t‰ tai BDD:t‰ \cite{specification}. Haastatteluissaan Adzic sai kirjassaan selville jopa sen, ett‰ hyvin tehtyn‰ selke‰t, yll‰pidett‰v‰t testit monesti jopa riittiv‰t ainoaksi dokumentaatioksi j‰rjestelm‰st‰, sill‰ niiden k‰yttˆ oli helpompaa kuin erillisten dokumenttien tuottaminen \cite{specification}. Useat BDD- ja ATDD-tyˆkalut, kuten esimerkiksi Cucumber \cite{cucumber} myˆs tukevat automaattisesti esimerkiksi nettisivujen luontia testeist‰, jolloin niist‰ saadaan dokumentaation kaltainen artefakti hyvin pienell‰ vaivalla.

\chapter{Behaviour-driven development}

\section{BDD:n l‰htˆkohdat ohjelmistokehityst‰ tukevana menetelm‰n‰}
BDD, eli Behaviour-driven development, on nimens‰ mukaisesti ohjelmistokehityksen malli, jossa ohjelmistojen kehityksen l‰htˆkohtana on niiden k‰ytt‰ytyminen \cite{bddintro}. Toisin kuin edell‰ k‰sitellyss‰ ATDD:ss‰, voidaan BDD:n painottavan enemm‰n kommunikaation merkityst‰ sidosryhmien v‰lill‰ kuin vain automaattisten hyv‰ksymistestien luontia. Yksi keinoista, joilla monissa BDD-testikehyksiss‰ parannetaan kommunikaatiota ja yhteisymm‰rryst‰ eri sidosryhmien, kuten ohjelmistokehitt‰jien ja toimialan asiantuntijoiden v‰lill‰, on l‰hell‰ luonnollista kielt‰ oleva kieli, jolla testej‰ m‰‰ritell‰‰n \cite{cucumberbook}. Esimerkiksi seuraavanlaisella muotoilulla voidaan m‰‰ritell‰ testiskenaario Cucumber-testikehyksess‰ \cite{cucumber}:

\begin{verbatim}
Feature: Generation
  In order to finish the thesis
  As a student
  I want to generate good BDD-examples

  Scenario: Generate example of behaviour
    Given I have program running
    When I press generate
    Then the result should be an example behaviour on the screen
\end{verbatim} 

Kuten skenaarion muotoilusta voidaan n‰hd‰, BDD:ss‰ testataan ennen kaikkea sit‰, toimiiko ohjelmisto oikein ja halutulla tavalla, eli sen k‰ytt‰ytymist‰. Verrattuna TDD:n matalan tason testeihin, joissa keskityt‰‰n yhden metodin toimintaan kerrallaan, ero on merkitt‰v‰. Yksi merkitt‰vist‰ asioista, joiden avulla BDD:ll‰ voidaan ohjata ohjelmistokehitysprosessia on tapa, jossa toimintojen tuottama lis‰arvo otetaan huomioon. T‰llˆin eniten lis‰arvoa tuottavia ominaisuuksia voidaan ensimm‰isen‰ l‰htea kehitt‰m‰‰n ja niille voidaan luoda BDD-testit, jotka nimet‰‰n sen mukaan, mit‰ j‰rjestelm‰n halutaan tekev‰n \cite{bddintro}.

Monilta osin BDD perustuu Test-driven developmentin parhaisiin k‰yt‰nteisiin ja samalla BDD:n tarkoituksena on formalisoida niit‰ \cite{cucumberbook}. TDD:n voidaankin ajatella auttavan kehitt‰ji‰ toteuttamaan ratkaisun oikein, kun taas ATDD ja BDD auttavat kehitt‰ji‰ toteuttamaan oikean ratkaisun \cite{cucumberbook}. Sek‰ TDD:st‰, ett‰ BDD:st‰ kummastakin lˆytyy komponentit, joilla on helppo selvent‰‰ eroja n‰iden kahden menetelm‰n v‰lill‰. Siin‰ miss‰ TDD:ss‰ keskityt‰‰n testeihin, joilla testataan yht‰ luokkaa ja sen metodien toimintaa, BDD:ss‰ vastaava komponentti on esimerkki, jolla kuvaillaan yhden luokan toivottua k‰ytt‰ytymist‰ \cite{tddbdd}. Siin‰ miss‰ TDD:ss‰ testien odotetaan menev‰n l‰pi, BDD:ss‰ halutaan ohjelmiston k‰ytt‰ytyv‰n oikein. BDD:ss‰ testeill‰ varmistetaan, ett‰ toiminnallisuus on oikea, eli tuottaa mahdollisimman paljon arvoa asiakkaalle, kun TDD:ss‰ testit testaavat toiminnallisuutta vain matalalla tasolla \cite{tddbdd}, eiv‰tk‰ ne ota asiakkaan tarpeita niink‰‰n huomioon.

\section{Teknologioista}
\subsection{Yleist‰ teknologioista}
Behaviour-driven developmentia varten on olemassa useita eri testikehyksi‰, jotka soveltuvat eri tarkoituksiin. Er‰it‰ esimerkkej‰ n‰ist‰ ovat Cucumber \cite{cucumber}, Jasmine \cite{jasmine}, Specflow \cite{specflow} ja RSpec \cite{rspec}. Mainittujen testikehysten suurin ero on alustat, joita ne tukevat. Jasmine on JavaScript-ohjelmointikielelle tehty testikehys, kun taas SpecFlow on ratkaisu Microsoftin .NET-alustan BDD-testaamiseen. Cucumber ja RSpec pohjautuvat molemmat Ruby-ohjelmointikieleen, mutta ne poikkeavat toisistaan kuitenkin muuten varsin paljon. Siin‰ miss‰ RSpec on ainoastaan Rubya tukeva kehys, jolla voidaan toteuttaa niin TDD- kuin BDD-testaustakin, niin Cucumber kehyksen‰ korostaa erityisesti m‰‰rittelyjen luettavuutta ja ymm‰rrett‰vyytt‰. RSpec ei tarjoa mahdollisuutta m‰‰ritell‰ erikseen l‰hell‰ selkokielt‰ olevia kuvauksia k‰ytt‰ytymisest‰, kuten Cucumberissa, vaan siin‰ koko testi on yhdess‰ yksitt‰isess‰ tiedostossa. T‰llˆin luettavuusero on varsin merkitt‰v‰, kun otetaan huomioon BDD:n l‰htˆkohta kommunikaation parantajana:

RSpec:
\begin{verbatim}
# example_spec.rb

require 'spec_helper'
describe "exampletest" do
  it "should have a page titled Example at '/example'" do
   get '/example'
   response.should have_xpath("//title", :text => "Example")
 end
end
\end{verbatim} 

Vastaavasti Cucumberiss‰ on erillisess‰ feature-tiedostossa m‰‰ritelty luonnollisen kaltaisella kielell‰ eri skenaariot, joiden mukaan ohjelman halutaan toimivan. T‰m‰n lis‰ksi on sitten erillinen Rubylla kirjoitettu tiedosto, jossa m‰‰ritell‰‰n, mit‰ feature-tiedostossa k‰ytetyt stepit tekev‰t. T‰ss‰ siis selv‰sti erotellaan liiketoiminnan kannalta t‰rke‰t m‰‰rittelyt erikseen l‰hes selkokieliseen muotoon, jolloin niiden tulkinta on verrattain helpompaa kuin esimerkiksi RSpecin tapauksessa suoraan Ruby-koodin lukeminen. Edell‰ esitellyn RSpec-testin kaltainen testi Cucumberilla voitaisiin toteuttaa esimerkiksi seuraavalla tavalla:

Cucumber:
\begin{verbatim}
# example.feature

Scenario: As a user I want to see correct page title
  Given I am on the home page
  When I go to example page
  Then I should be on the page with the title: "Example" 

# example_steps.rb

Given /^I am on the home page$/ do
  visit '/'
end

When /^I go to the example page$/ do
  visit '/example'
end

Then /^I should be on the page with the title: "([^"]*)"$/
do |page_title|
  response.should have_xpath("//title", :text => "#{page_title}")
end
\end{verbatim}

Esimerkeist‰ voidaan huomata, kuinka Cucumberilla esimerkkiskenaariosta tulee paljon helpommin luettava henkilˆille, jotka eiv‰t ole teknisesti orientoituneita. Siin‰ miss‰ RSpec-testiss‰ samaan tiedostoon on m‰‰ritetty testin kuvaus kuin sen toiminnalisuuskin, niin Cucumberissa testi on selv‰sti erikseen kuvattu feature-tiedostossa, jolloin eri sidosryhmien edustajat voivat keskitty‰ vain sen sis‰ltˆˆn, eik‰ tekninen aineisto, eli eri steppien m‰‰ritykset, ole sekoittamassa asiaan perehtym‰tˆnt‰ henkilˆ‰.

Yhteist‰ l‰hes kaikille BDD-testikehyksille on niiden k‰ytt‰m‰ testitapausten muoto yleisell‰ tasolla. Dan North esittelee t‰m‰n muodon Behaviour-driven developmentin konseptia esittelev‰ss‰ blogitekstiss‰‰n \cite{bddintro}. Perinteinen pohja k‰ytt‰j‰tarinoille koostuu usein jotakuinkin seuraavanlaisista osista:
\begin{itemize}
\item Roolissa A
\item Haluan tehd‰ asian B
\item Jotta tapahtuu asia C
\end{itemize}
T‰m‰ kyseisenlainen pohja toimii myˆs Northin m‰‰rittelem‰n testitapausten muodon pohjana. T‰st‰ mallista North kehitti uuden mallin, jonka avulla voidaan k‰ytt‰j‰tarinat kirjoittaa suoraan hyv‰ksynt‰testien muotoon.
\begin{itemize}
\item Given (what is known/done beforehand)
\item When (something is done)
\item Then (something happens)
\end{itemize}
T‰llaista Given-When-Then -muotoa k‰ytt‰v‰‰ suuri osa BDD-testikehyksist‰ testiens‰ m‰‰ritt‰miseen. Poikkeuksiakin toki on, esimerkiksi aiemmin esimerkkin‰ ollut RSpec-testikehys Rubylle \cite{rspec}, jossa ei ole erikseen m‰‰rittelyj‰ testitapauksille, vaan kaikki sis‰ltˆ lˆytyy koodin seasta. Esimerkiksi seuraavasta RSpec-testist‰ voidaan lˆyt‰‰ vastaavat osat:
\begin{verbatim}
require 'spec_helper'

describe Example do
  it "is not valid without a title" do
    example = Example.new(title: nil)
    example.should_not be_valid
  end
end
\end{verbatim}
T‰ss‰ voidaan ajatella, ett‰ pohjatietona, eli Given-osiona olisi tilanne, jossa on mahdollista luoda uusi Example. When-kohtana olisi Example.new(title: nil) eli luodaan uusi Example. T‰llˆin odotetaan tuloksena, ett‰ uusi Example ei olisi validi, mik‰ vastaisi siis Then-kohtaa Dan Northin muodossa. Voidaan kuitenkin mietti‰, onko v‰ltt‰m‰tt‰ hyˆdyllist‰ yritt‰‰ puristaa jokaista testikehyst‰ ennaltam‰‰ritettyyn muotoon, sill‰ RSpec poikkeaa muista kehyksist‰ muutenkin verrattain paljon sen tarjotessa mahdollisuudet laajemminkin testivetoiseen kehitykseen Rubylla kuin vain BDD:n toiminnallisuuksia.

Muista testikehyksist‰ esimerkiksi Cucumber \cite{cucumberbook} k‰ytt‰‰ t‰ysin Dan Northin m‰‰rittelem‰‰ muotoa \cite{bddintro} testeilleen, kun taas JavaScript-testikirjasto Jasminen \cite{jasmine} ratkaisu on hyvin samanlainen kuin RSpecin ratkaisu, eli Jasminessakaan ei ole erikseen m‰‰ritelty luonnollisella kielell‰ testej‰ erikseen. Specflow \cite{specflow}, joka on testikehys .NET, Windows Phone ja Mono-alustoille, on sen sijaan toteutettu vastaamaan Dan Northin m‰‰rittelem‰‰ mallia, eli Given-When-Then -malliset m‰‰ritykset testiesimerkeille toteutetaan siin‰ erikseen ja n‰ille m‰‰rityksille ohjelmoidaan tulkit, joilla m‰‰ritell‰‰n mit‰ testit tekev‰t.

\subsection{Parsereista}
Yksi t‰rke‰ osa monia BDD-testikehyksi‰ on niiden k‰ytt‰m‰t parserit, joilla tulkitaan m‰‰riteltyj‰ testitapauksia ajettavaksi ohjelmakoodiksi. N‰ill‰ parsereilla on kaikilla jokin hyvin m‰‰ritelty syntaksinsa, jota ne ymm‰rt‰v‰t. Yksi parsereista on esimerkiksi avoimen l‰hdekoodin Gherkin \cite{gherkin}, jota k‰ytt‰v‰t Cucumber \cite{cucumber} ja sen sukuiset BDD-testikehykset, kuten esimerkiksi SpecFlow \cite{specflow}. Gherkinin syntaksi on hyvin yksinkertainen, joka edesauttaa sit‰, ett‰ eri sidosryhmien edustajat ymm‰rt‰v‰t ja parhaassa tapauksessa voivat jopa itse luoda uusia testitapauksia. T‰llˆin tarvitaan erityisesti kehitystiimin ja muiden sidosryhmien yhteistyˆt‰, sill‰ t‰ss‰kin tapauksessa kehitystiimin teht‰v‰ksi j‰‰ kirjoittaa testitapauksia vastaava ohjelmakoodi, jotta testitapauksista saadaan toimivia. Martin Fowler kirjoittaakin blogissaan \cite{businessdsl}, ett‰ ennen kaikkea t‰rke‰‰ ja hyˆdyllist‰ on se, ett‰ sidosryhmien edustajat kykenet lukemaan ja ymm‰rt‰m‰‰n koodia, tai t‰ss‰ tapauksessa testitapausten kuvauksia, sill‰ se toimii ‰‰rimm‰isen hyv‰n‰ kommunikaatiov‰lineen‰ eri osapuolten v‰lill‰. Seuraavassa on esimerkki Gherkin-dokumentista, jossa m‰‰ritell‰‰n esimerkkiskenaario:
\begin{verbatim}
Feature: Software installation
  Scenario: Uninstall software
    Given a software named "example" exists
    When I press uninstall software
    Then the software named "example" should be removed
\end{verbatim}
T‰ss‰ esimerkiss‰ ainoat kohdat, jotka m‰‰ritell‰‰n Gherkinin syntaksissa, ovat kaikilla riveill‰ niiden alut, eli Feature, Scenario, Given, When ja Then \cite{gherkin2}. Kaikki muu sis‰ltˆ, mit‰ testitapaukset sis‰lt‰v‰t, on testien kirjoittajan itse luomaa sis‰ltˆ‰, eli kaikki muut kohdat tulee m‰‰ritell‰ steppien kuvauksissa testikehyksen k‰ytt‰m‰ll‰ ohjelmointikielell‰. Cucumberin tapauksessa t‰m‰ voitaisiin tehd‰ esimerkiksi Rubylla tai jollakin muulla ohjelmointikielell‰, jota Cucumber tukee, kuten esimerkiksi Javalla. Edelt‰v‰n esimerkin Given-kohta voitaisiin m‰‰ritell‰ toimivaksi testiksi esimerkiksi Java-ohjelmointikielt‰ k‰ytt‰en seuraavalla tavalla:
\begin{verbatim}
@Given("a software named (.*) exists")
public void softwareExists(string software) {
    // T‰ss‰ voitaisiin tehd‰ ohjelmistolla mit‰ tahansa,
    // esimerkiss‰ halutaan hakea ohjelmistoa
    // sen nimell‰ SoftwareServicelt‰
    getSoftwareService.findSoftware(software);
}
\end{verbatim} 

Gherkinin sijasta monet BDD-testikehykset k‰ytt‰v‰t omia parsereitaan. Esimerkiksi RSpec \cite{rspec} ja Jasmine \cite{jasmine} eiv‰t k‰yt‰ Gherkini‰, vaan niiss‰ on toteutettu omat parserit testien tulkkaamiseen. Yksi eduista, joita saavutetaan yhden parserin yleisyydell‰ eri testikehyksiss‰, on se, ett‰ t‰m‰ edesauttaa testien uudelleenk‰ytett‰vyytt‰. Kun eri testikehykset k‰ytt‰v‰t samaa parseria, niin samat testim‰‰ritykset toimivat niille kaikille. T‰m‰ onkin yksi merkitt‰v‰ havainto etsitt‰ess‰ ratkaisua tutkielman tutkimuskysymykseen mobiilialustojen BDD-testaamisesta yhdell‰ testisetill‰. T‰t‰ k‰sitell‰‰n myˆhemmin lis‰‰ kappaleessa \ref{chap:platforms}.

\chapter{BDD:n tarjoamat liiketoiminnalliset edut}
Behaviour-driven developmentin voidaan n‰hd‰ tarjoavan muitakin hyˆtyj‰ sen lis‰ksi, ett‰ se toimii k‰yt‰nnˆn tapana kehitt‰‰ ohjelmistoja teknisell‰ tasolla ohjelmistokehitt‰jien toimesta. Yksi t‰rkeimmist‰ l‰htˆkohdista, joille BDD:n k‰yt‰nteet on kehitetty, on kommunikaation lis‰‰minen ja parantaminen asiakkaan ja kehitystiimin v‰lill‰ \cite{specification}. V‰lillisesti t‰m‰n kommunikaation lis‰‰misen myˆt‰ BDD:n k‰ytˆll‰ pyrit‰‰n toteuttamaan jatkuvasti entist‰ paremmin oikeita asioita, eli pyrit‰‰n minimoimaan eri sidosryhmien v‰lisi‰ n‰kemyseroja toiminnallisuuksien v‰lill‰. T‰h‰n p‰‰st‰‰n erityisesti sill‰, ett‰ asiakkaan kanssa yhdess‰ m‰‰ritell‰‰n testiesimerkkej‰ ja toiminnallisuuksia \cite{businessdsl}.  

\section{Asiakkaan k‰ytt‰j‰tarinoista hyv‰ksymistesteiksi}
Kuten edell‰ mainittiin, on yksi suurimmista BDD:n tarjoamista eduista sen luomat mahdollisuudet tyˆskennell‰ yhdess‰ asiakkaan kanssa tuotetun tyˆn arvon maksimoimiseksi. Jos toiminnallisia vaatimuksia m‰‰ritell‰‰n jatkuvasti yhdess‰ asiakkaan kanssa, ei miss‰‰n vaiheessa pit‰isi synty‰ tilannetta, jossa kehitystiimi toteuttaa ominaisuuksia, jotka ovat v‰‰ri‰ tai valmistuessaan jo vanhentuneita tai hyˆdyttˆmi‰ asiakkaan liiketoiminnan kannalta. Erityisen hyvin t‰llaiseen tilanteeseen p‰‰st‰‰n, kun BDD:n toimintatavat yhdistet‰‰n Scrumiin tai johonkin muuhun inkrementaaliseen prosessimalliin, jossa vaatimuksia ei lyˆd‰ heti projektin alussa lukkoon, vaan niit‰ tyˆstet‰‰n jatkuvasti projektin edetess‰.

Esimerkiksi Scrumin \cite{scrumguide} yhteydess‰ BDD:n k‰yt‰ntˆj‰ voitaisiin hyˆdynt‰‰ seuraavalla tavalla:
\begin{itemize}
\item Product ownerin johdolla teht‰v‰ss‰ tuotebacklogin groomauksessa, eli siistimisess‰ ja priorisoinnissa voidaan yhdess‰ asiakkaan kanssa m‰‰ritell‰ tuleville toiminnallisuuksille hyv‰ksymiskriteereit‰, eli k‰yt‰nnˆss‰ kriteereit‰ sille, milloin voidaan katsoa jonkin ominaisuuden olevan valmis
\item Samalla backlogin groomauksessa voitaisiin vaatimukset kirjoittaa yhdess‰ asiakkaan kanssa suoraan oikeaan muotoon BDD:t‰ varten, eli k‰ytt‰en esimerkiksi Gherkinin syntaksia, jos projektissa k‰ytetty BDD-testikehys sit‰ k‰ytt‰isi.
\item Mahdollisesti vaatimuksia voitaisiin m‰‰ritell‰ myˆs erillisess‰ tilaisuudessa, jos sen koettaisiin olevan liian raskasta groomauksen yhteydess‰.
\item Sprint planningissa sprintiin mukaan otettavia tˆit‰ arvioitaisiin testiesimerkkien muotoon tehtyjen vaatimusm‰‰rittelyjen pohjalta.
\item Sprinttien aikana kehitystiimi toteuttaa ominaisuuksia m‰‰riteltyjen testitapausten avulla. Kehitystiimi toteuttaa ensin m‰‰ritellyille testitapauksille testin teknisen osan, eli toimivan koodin ensin testille, jotta testi‰ voidaan k‰ytt‰‰ ja t‰m‰n j‰lkeen viel‰ ohjelmakoodi itse ominaisuudelle, jotta testi menee l‰pi. 
\item Ep‰selviss‰ tilanteissa m‰‰riteltyj‰ testej‰ voidaan k‰yd‰ l‰pi yhdess‰ product ownerin kanssa, jolla pit‰isi jatkuvasti olla projektissa paras tieto siit‰, mit‰ halutaan toteuttaa. 
\end{itemize}
T‰m‰ on vain esimerkki siit‰, kuinka BDD:n toimintatavat voitaisiin yhdist‰‰n k‰ytˆss‰ oleviin vakiintuneisiin ohjelmistokehityksen prosessimalleihin. K‰yt‰nnˆss‰ kuitenkin tavat voivat vaihdella tiimist‰ ja projektista riippuen sen mukaan, mik‰ parhaiten oikeasti toimii. Mit‰‰n tarkasti m‰‰riteltyj‰ toimintatapoja BDD:n soveltamiseen ei ole mink‰‰n tahon toimesta kehitetty, vaan kuten monissa muissakin uusissa ja vakiintumattomissa tietotekniikan alan malleissa, parhaat k‰yt‰nteet muuttuvat ja kehittyv‰t jatkuvasti.

\section{BDD:n hyˆdynt‰minen ohjelmistoprojektien ulkoistuksessa}
Er‰s mahdollisuus, jonka BDD tarjoaa, on sen tyˆtapojen hyˆdynt‰minen projekteissa, joissa koko ohjelmistokehitys tai vain osia siit‰ on ulkoistettu. Monesti ulkoistamisen syyt liittyv‰t taloudellisiin seikkoihin, eli ulkoistettuna tyˆt saadaan halvemmalla toteutettua. 2007 julkaistussa artikkelissaan \cite{qualityrisk} Salma, Lyes, Abderahman ja Younes kuitenkin toteavat, ett‰ tˆiden ulkoistaminen lis‰‰ erityisen paljon laatuun liittyvi‰ riskitekijˆit‰ projekteille. T‰llaisia riskej‰ ovat muun muassa todellisten kulujen kasvaminen, riippuvuuden kasvaminen yhteen toimittajaan sek‰ mahdollisesti tuote, joka ei t‰yt‰ sille asetettuja vaatimuksia \cite{qualityrisk}.

Edell‰mainituista ongelmista monet osuvat paljolti samalle alueelle kuin ongelmat, joita BDD:t‰ k‰ytt‰m‰ll‰ yritet‰‰n ratkoa. K‰yt‰nnˆss‰ siis soveltamalla BDD:t‰ ohjelmistoprojektien ulkoistuksessa, voitaisiin mahdollisesti p‰‰st‰ eroon joistain siihen liittyvist‰ ongelmista ja riskitekijˆist‰.

Ongelma, jossa ulkoistettuna kehitetty tuote ei t‰yt‰ sille asetettuja vaatimuksia, voidaan v‰ltt‰‰ BDD:t‰ soveltamalla. Olennaista t‰ss‰kin on kommunikaation t‰rkeys eri sidosryhmien v‰lill‰, kuten t‰ss‰ tapauksessa esimerkiksi voisi olla kyseess‰ asiakas, ohjelmistoprojektin toimittaja ja viel‰ kehitystiimin osa toisessa maassa. T‰llaisessa tilanteessa monesti perinteinen tapa toimia olisi sellainen, ett‰ toimittaja m‰‰rittelee asiakkaan kanssa vaatimuksia, jotka sitten l‰hetet‰‰n toteutettavaksi kolmannen osapuolen toimesta, jolloin mahdollisia v‰‰rink‰sityksi‰ ja informaatiokatkoksia voi synty‰ jo monessa kohdassa. Pelk‰st‰‰n vaatimusten merkityksest‰ voi olla t‰llaisessa tilanteessa jo kolme eri n‰kemyst‰. T‰llaiseen ongelmaan voitaisiin hakea ratkaisua toimimalla BDD:n keinoin ja jakamalla tyˆt‰ esimerkiksi seuraavalla tavalla:
\begin{itemize}
\item Tˆiden jakaminen tarkoituksenmukaisesti. T‰ll‰ tarkoitetaan nyt erityisesti sit‰, mill‰ tavoin tyˆt voidaan jakaa kaikkien kolmen osapuolen kesken ja miten t‰ss‰ voitaisiin mahdollisesti viel‰ hyˆdynt‰‰ BDD:t‰. Yksi t‰rkeist‰ asioista tˆiden jakamiseen liittyen on vaatimusten m‰‰rittely, joka voidaan nyt tehd‰ esimerkkien avulla. M‰‰rittelyss‰ tyˆt voidaan jakaa esimerkiksi siten, ett‰ asiakas tuottaa vaatimukset yhdess‰ projektin toimittajan kanssa, jolloin he tekev‰t m‰‰rittelyt Dan Northin mallin \cite{bddintro} mukaisesti esimerkkien muotoon. T‰m‰n j‰lkeen projektin toimittajan puolesta voitaisiin toteuttaa esimerkeist‰ toimivat testit valitulla teknologialla, esimerkiksi Cucumberia k‰ytt‰m‰ll‰. Lopulta ulkoistettu kehitystiimi toteuttaisi ominaisuudet pohjautuen m‰‰riteltyihin vaatimuksiin ja esimerkkeihin.  
\item Vaikka tyˆt jaettaisiinkin esimerkiksi edell‰mainitulla tavalla, on t‰rke‰‰, ett‰ toteuttavan tiimin ja muiden osapuolten v‰lill‰ s‰ilyy hyv‰ kommunikaatioyhteys senkin j‰lkeen, kun testitapaukset on toimitettu kehitystiimille, sill‰ n‰m‰k‰‰n eiv‰t ole v‰ltt‰m‰tt‰ t‰ysin yksiselitteisi‰, vaan saattavat vaatia selvennyst‰ etenkin, jos yksik‰‰n tiimin j‰sen ei ole ollut mukana testej‰ toteuttamassa. Ihannetilanne olisikin, jos edes joku kehitystiimin edustaja kykenisi olemaan mukana tekem‰ss‰ testiesimerkkej‰, jolloin kaikilla projektissa mukana olevilla ryhmill‰ olisi samanlainen k‰sitys siit‰, mit‰ todella ollaan tekem‰ss‰. Aina t‰llainen ei kuitenkaan v‰ltt‰m‰tt‰ ole yksinkertaisesti mahdollista, johtuen esimerkiksi maantieteellisest‰ sijainnista tai aikaeroista kehitystiimin ja projektin toimittajan sek‰ asiakkaan v‰lill‰.
\item Tˆiden tekeminen k‰ytt‰en inkrementaalista ohjelmistokehityksen prosessimallia. T‰m‰ ei varsinaisesti liity BDD:hen muulla tavoin kuin siten, ett‰ BDD on syntynyt hyvin vahvasti ketterien menetelmien yhteydess‰ ja tavallisesti BDD:t‰ k‰ytet‰‰nkin ennenkaikkea inkrementaalisissa projekteissa. T‰llˆin mahdolliset ongelmat ja v‰‰rinymm‰rrykset ulkoistetun kehitystiimin sis‰ll‰ selvi‰v‰t aiemmin kuin vasta projektin lopussa ja ongelmiin voidaan puuttua heti niiden tullessa esiin.
\end{itemize}  

Behaviour-driven developmentin soveltaminen ei kuitenkaan ratkaise l‰hesk‰‰n kaikkia ulkoistamiseen liittyvi‰ ongelmia, vaikka sen toimintatapojen avulla voidaan v‰hent‰‰ joitain olemassa olevia riskej‰. Artikkelissaan Salma et al. toteavatkin, ett‰ ulkoistamisp‰‰tˆkseen liittyy aina lukematon m‰‰r‰ riskej‰, joista jonkun on vain otettava projektissa vastuu \cite{qualityrisk}. Monet ulkoistamiseen liittyv‰t riskit ovatkin sellaisia, joihin ei BDD:ll‰ voida vaikuttaa mill‰‰n tavalla. Esimerkiksi ulkoistamisesta mahdollisesti seuraavat tietotaidon h‰vi‰minen ulkoistavasta yrityksest‰ sek‰ mahdolliset kulttuurilliset ongelmat eri tahojen v‰lill‰ ovat sellaisia, joita BDD:n tapojen soveltaminen ei suoranaisesti selvit‰. 

\chapter{BDD mobiilialustoilla}
T‰ss‰ tutkielmassa keskityt‰‰n erityisesti tutkimaan BDD:t‰ mobiilialustoilla. Mobiilialustoilla ohjelmistokehitys eroaa monilta osin paljon tavanomaisesta tyˆpˆyt‰ymp‰ristˆihin keskittyneest‰ ohjelmistokehityksest‰ johtuen suuresta m‰‰r‰st‰ markkinoilla olevia mobiilik‰yttˆj‰rjestelmi‰. Sen lis‰ksi, ett‰ n‰iden niin kutsuttujen natiivisovellusten kehitys ja ekosysteemit poikkeavat tavallisesta, ovat mobiililaitteet tuoneet omat haasteensa myˆs web-teknologioihin. T‰ss‰ tutkielmassa keskityt‰‰nkin tutkimaan ohjelmistokehityst‰ BDD:n avulla n‰ist‰ kahdesta n‰kˆkulmasta, eli ensin k‰sitell‰‰n natiivisovellusten testaamista BDD-menetelmill‰ eri mobiilialustoilla. T‰m‰n j‰lkeenn k‰sitell‰‰n erikseen moderneilla web-teknologioilla toteutettujen HTML5-mobiilisovellusten BDD-testaamista.

\section{Natiivisovellukset}
Tutkielmaan valittiin otokseksi kirjoitushetken kolme suosituinta mobiilik‰yttˆj‰rjestelm‰‰ \cite{marketshare}, joiden kohdalla tutkittiin mahdollisuuksia testata niiden natiivisovelluksia Behaviour-driven developmentin keinoin. K‰yttˆj‰rjestelmist‰ mukana tutkimuksessa olivat Googlen Android, Applen iOS ja Microsoftin Windows Phone. Seuraavassa k‰yd‰‰n l‰pi eri mobiilik‰yttˆj‰rjestelmille olemassa olevia BDD-testikehyksi‰ ja niiden ominaisuuksia, kuten niiden k‰ytt‰mi‰ parsereita.  

\subsection{iOS BDD-frameworkit}
Yksi tunnetuimmista iOS:n BDD-testikehyksist‰ on avoimeen l‰hdekoodiin perustuva Frank \cite{frank}, jonka toiminta pohjautuu jo aiemmin useasti mainittuun Cucumberiin ja sit‰ myˆten myˆs Gherkin-parseriin. T‰m‰ tarkoittaa sit‰, ett‰ Frank-testikehyksen testit voidaan m‰‰ritell‰ samalla tavoin kuin Cucumber-testit \cite{cucumber} ja muiden Gherkin-parseria k‰ytt‰vien testikehysten testit \cite{gherkin}. Frankin stepit m‰‰ritell‰‰n samalla tavoin Ruby-ohjelmointikielell‰ kuin monissa muissakin Cucumberiin pohjautuvissa testikehyksiss‰. Toisin kuin monissa muissa testikehyksiss‰, Frankissa tulee mukana valmiina setti valmiiksim‰‰riteltyj‰ testisteppej‰ \cite{franksteps}, joka varmasti alentaa kynnyst‰ l‰hte‰ kokeilemaan BDD-kehityst‰, jos ei ole aiheeseen aiemmin tutustunut. Testisteppien kirjoittamiseenkin Frank tarjoaa helpotusta FrankHelper-moduulin muodossa \cite{frankhelper}, joka tarjoaa valmiiksi ohjelmoituja apukirjastoja, joiden avulla uusien testien kirjoittamista ei tarvitse aloittaa t‰ysin tyhj‰st‰, vaan ne tarjoavat kattavan pohjan useimmin k‰ytettyj‰ metodeita Frankin hyˆdynt‰miseen.

Toinen BDD-testikehys Applen iOS-k‰yttˆj‰rjestelm‰lle on Kiwi \cite{kiwi}, joka poikkeaa paljolti edell‰ k‰sitellyst‰ Frank-testikehyksest‰. Kiwiss‰ testit kirjoitetaan Objective-C -ohjelmointikielell‰, eli samalla kielell‰, jolla iOS:n natiivisovellukset muutenkin kirjoitetaan. Kiwiss‰ testien kirjoittaminen on muutenkin integroitu vahvasti iOS:n tavallisiin sovelluskehitysv‰lineisiin, kuten Xcode-editoriin \cite{xcode}. Kiwi-testej‰ voidaan kirjoittaa ja ajaa suoraan Xcode-kehitysymp‰ristˆst‰, jolloin testien tekemisen pit‰isi olla mahdollisimman yksinkertaista iOS-sovelluksia teht‰ess‰. Kuten edell‰ mainittiin, poikkeaa Kiwin testit syntaksiltaan muista iOS:n BDD-testikehyksist‰, sill‰ sen testit kirjoitetaan Objective-C:ll‰. Samalla tavoin kuin esimerkiksi RSpec-testeiss‰, myˆs Kiwiss‰ kaikki testit kirjoitetaan samaan tiedostoon, eik‰ mit‰‰n erillisi‰ testien kuvauksia ja testisteppien m‰‰rityksi‰ ole. Kiwi ei siis k‰yt‰ Cucumber-pohjaisista testikehyksist‰ tuttua Gherkin-parseria, vaan siin‰ on t‰ysin oma toteutuksensa. Esimerkiksi seuraavassa testataan, ett‰ henkilˆ-objektilla on nimi ja kaksi vanhempaa:
\begin{verbatim}
describe(@"Person", ^{
    context(@"when newly created", ^{
        it(@"should have a name", ^{
            id person = [Person person];
            [[person.name should] equal:@"Test Person"];
        });

        it(@"should have 2 parents", ^{
            id person = [Person person];
            [[[person should] have:2] parents];
        });
    });
});
\end{verbatim}

Kolmantena esimerkkin‰ Applen iOS:n BDD-testikehyksist‰ mukaan valittiin Calabash \cite{calabash}, joka edustaa viel‰ kolmatta, edellisist‰ v‰h‰n poikkeavaa l‰htˆkohtaa BDD-testaamiselle iOS-k‰yttˆj‰rjestelm‰ll‰. Yksi suurimmista eroista Calabashin ja edell‰ k‰siteltyjen Frankin ja Kiwin v‰lill‰ on se, ett‰ Calabash tukee iOS-k‰yttˆj‰rjestelm‰n lis‰ksi myˆs Androidia. T‰m‰n myˆt‰ Calabashin avulla voidaan siis suoraan testata samoilla testeill‰ niin Android- kuin iOS-sovelluksetkin. Calabash tukee Cucumberia, eli siin‰ testit voidaan m‰‰ritell‰ samalla tavoin k‰ytt‰en Gherkin-parserin ymm‰rt‰m‰‰ syntaksia kuin monissa muissa Cucumberiin pohjautuvissa testikehyksiss‰. Kummassakin versiossa, eli calabash-androidissa \cite{calabashandroid} sek‰ calabash-ios:ss‰ \cite{calabashios} testien stepit m‰‰ritell‰‰n Ruby-ohjelmointikielell‰, eli testikehyksen k‰yttˆ on hyvin pitk‰lti samankaltaista kuin muidenkin Cucumber-testikehysten k‰yttˆ. Calabash poikkeaa muista kehyksist‰ myˆs siin‰, ett‰ siihen on integroitu testikehyst‰ p‰‰asiallisesti kehitt‰v‰n yrityksen, Xamarinin, toimesta kaupallisia palveluita, kuten esimerkiksi pilvipalveluita, joiden avulla kehitt‰j‰t voivat testata sovelluksiaan pilvi-infrastruktuurissa is‰nnˆidyiss‰ testiymp‰ristˆiss‰ \cite{xamarincloud}.

\begin{figure}
\centering
\includegraphics[width=0.95\textwidth]{calabash}
\caption{Calabash-androidin arkkitehtuuri \cite{calabash}}
\end{figure}

\subsection{Android BDD-frameworkit}
Kuten iOS:lle, myˆs Googlen Android-k‰yttˆj‰rjestelm‰lle on olemassa useita eri vaihtoehtoisia testikehyksi‰, joilla ohjelmistoja voidaan kehitt‰‰ BDD-tyyliin. Yksi vaihtoehdoista on jo edell‰ k‰sitelty Calabash \cite{calabash}, josta lˆytyy iOS-version ohella myˆs Android-versio. Vaikka Calabash onkin t‰ll‰ hetkell‰ yksi tunnetuimmista BDD-testikehyksist‰ mobiilialustoille, on Androidille kuitenkin sen lis‰ksi olemassa useita muitakin vaihtoehtoja, joihin kuuluu sek‰ Cucumberiin pohjautuvia ratkaisuja kuin myˆs t‰ysin Cucumberista erillisi‰ omanlaisia ratkaisujaan.

Yksi UI-testauskehys ja BDD-testikehys Androidille on robotium \cite{robotium}, joka on avoimen l‰hdekoodin testikehys, jolla voidaan testata niin ohjelmistoja, joista on l‰hdekoodit saatavilla, kuin myˆs ohjelmistoja, joista on saatavilla ainoastaan Androidin apk-pakettitiedosto. Samalla tavoin kuin esimerkiksi Rubyn RSpec-testikirjastossa, myˆsk‰‰n robotiumissa ei ole erillisi‰ m‰‰rityksi‰ testitapauksille ja erikseen suoritettaville testistepeille. Robotiumissa testit m‰‰ritell‰‰n kokonaisuudessaan yhdess‰ tiedostossa samaan tapaan kuin esimerkiksi Java-ohjelmointikieless‰ perinteiset JUnit-yksikkˆtestit. T‰lt‰ osin robotium ei siis toimi samalla tavoin kuin Dan Northin m‰‰ritelm‰ BDD:n testien muodosta \cite{bddintro}. Ohessa on esimerkki robotium-testist‰, jossa testataan, ett‰ ohjelmistossa lˆytyy MENU-nappia painamalla Examples-valikon alta kolme eri ``Example''-teksti‰ numeroituna.

\begin{verbatim}
public class ExampleTest extends
                ActivityInstrumentationTestCase2<ExampleActivity> {

  private Solo solo;

  public ExampleTest() {
                super(ExampleActivity.class);
  }

  public void setUp() throws Exception {
        solo = new Solo(getInstrumentation(), getActivity());
  }
  
  public void testMenuHasMultipleExamples() throws Exception {
  
                solo.sendKey(Solo.MENU);
                solo.clickOnText("Examples");
                Assert.assertTrue(solo.searchText("Example 1"));
                Assert.assertTrue(solo.searchText("Example 2"));
                Assert.assertTrue(solo.searchText("Example 3"));
  }

   @Override
   public void tearDown() throws Exception {
        solo.finishOpenedActivities();
  }
}
\end{verbatim}

Kuten edell‰ esitellyst‰ esimerkist‰ helposti huomataan, ei robotium tarjoa l‰hesk‰‰n yht‰ hyv‰‰ luettavuutta testeilleen kuin monet muut BDD-testikehykset, joissa testej‰ voidaan m‰‰ritell‰ luonnollisia kieli‰ l‰hell‰ olevilla kielill‰. Robotiumin testit ovatkin puhtaasti Javaa, joka tarkoittaa sit‰, ett‰ robotiumin kohdalla menetet‰‰n yksi t‰rke‰ etu verrattuna muihin BDD-testikehyksiin, joka on testikehysten tarjoama kommunikaatiomahdollisuuksien helpotus. Robotiumin kohdalla ei ole en‰‰ j‰rkev‰‰, eik‰ monesti edes mahdollista, ett‰ asiakkaan edustaja osallistuisi testien luontiin yht‰ tiiviisti kuin muiden BDD-testikehysten kohdalla, sill‰ robotiumin kanssa asiakas ei pysty keskustelemaan testeist‰ mitenk‰‰n j‰rkev‰sti, eik‰ kertomaan niihin omia lis‰yksi‰‰n ilman asiantuntemusta Java-ohjelmointikielest‰. T‰st‰ syyst‰ voidaankin mietti‰ ovatko robotium ja esimerkiksi RSpec \cite{rspec} oikeastaan BDD-testikehyksi‰ vai jonkinlaisia v‰limuotoja yksikkˆtestikehysten ja BDD-testikehysten v‰lill‰. Toisaalta robotiumin voidaan ajatella myˆs olevan vain puhtaasti testikehys automaattiseen k‰yttˆliittym‰testaukseen.

Kolmantena esimerkkin‰ Calabashin ja robotiumin ohella Androidin BDD-testikehyksist‰ on puhtaasti Cucumber-pohjainen ratkaisu, eli Cucumber-Android \cite{cucumberandroid}, joka on osa Cucumber-JVM -projektia \cite{cucumberjvm}, jossa kehitet‰‰n puhtaasti Java-implementaatiota Cucumberista. Se, mill‰ tavoin Cucumber-Android poikkeaa esimerkiksi edell‰ k‰sitellyst‰ Calabashista on siin‰, ett‰ kyseinen kehys pohjautuu t‰ysin Javaan, eli esimerkiksi kaikki testistepit m‰‰ritell‰‰n siin‰ Javalla. Cucumber-JVM on myˆs uusi testikehys ja se onkin vasta kehitysasteella kirjoitushetkell‰. Yhten‰ Cucumber-JVM:n p‰‰kehitt‰jist‰ toimii Aslak Helles¯y, joka on muutenkin hyvin suuressa roolissa Cucumberin kehityksess‰ ja h‰n onkin kirjoittanut siit‰ jopa kirjan \cite{cucumberbook}. Cucumber-JVM:n ollessa viel‰ valmistumaton projekti monilta osin, ei se tarjoa kovin kattavia tutoriaaleja tai ohjeita verrattuna muihin Androidin testikehyksiin. Cucumber-JVM tukee laajasti myˆs muita JVM-pohjaisia ohjelmointikieli‰, kuten esimerkiksi Scalaa ja Clojurea. Tuki n‰ille kielille on toteutettu omien moduuliensa kautta, jolloin kehitt‰j‰t voivat ottaa k‰yttˆˆn vain tarvitsemansa moduulit riippuen k‰ytetyst‰ ohjelmointikielest‰ \cite{cucumberjvm}. Cucumber-JVM:n kehityksess‰ on panostettu myˆs sen toimivuuteen esimerkiksi eri kehitysymp‰ristˆjen kanssa ja testej‰ voidaankin ajaa suoraan kaikilla JUnit-yhteensopivilla IDE:ill‰ k‰ytt‰en cucumber-junit -moduulia sek‰ myˆs Android-emulaattorilla cucumber-android -moduulia k‰ytt‰en \cite{cucumberjvm}. N‰in ollen Cucumber-Android ja Cucumber-JVM tarjoavat yhden vaihtoehdon BDD-testaamiseen Androidilla. Ne eiv‰t kuitenkaan viel‰ tarjoa yht‰ valmista ja helpostil‰hestytt‰v‰‰ ratkaisua kuin muutamat muut Androidin BDD-testikehykset, mutta n‰iden kohdalla etuna on sen sijaan se, ett‰ niit‰ kehitet‰‰n alkuper‰isen Cucumberin kehitt‰jien toimesta, jolloin riski projektin yll‰tt‰v‰st‰ p‰‰ttymisest‰ tai suunnanmuutoksesta on mahdollisesti pienempi kuin kolmannen osapuolen projekteissa. 

\subsection{Windows phone BDD-frameworkit}

\section{HTML5-sovellukset}

\subsection{HTML5-sovellusten BDD-testaaminen}

\subsection{Natiivisovellusten tuottaminen HTML5-sovelluksista}

\chapter{Crossplatform-testaaminen eri mobiilialustoilla}
\label{chap:platforms}

\section{Mahdollisuudet testata kaikki alustat yhdell‰ testisetill‰}

\subsection{Samaa parseria k‰ytt‰vien BDD-testikehysten k‰ytt‰minen}

\subsection{HTML5}

\chapter{Pohdintaa}

\chapter{Yhteenveto}

Yhteenveto t‰h‰n

\begin{thebibliography}{9} % numero aaltosuluissa kertoo, miten paljon
                           % varataan tilaa viitenumerolle

\bibitem{tutkimuspaska}
Levy, Y. \& Ellis, T. J. \textit{A Systems Approach to Conduct an Effective Literature Review in Support of Information Systems Research},
Informing Science Journal, 9, 2006.

\bibitem{constructive}
Gordana Dodig Crnkovic \textit{Constructive Research and Info-Computational Knowledge Generation},
School of Innovation, Design and Engineering, Computer Science Laboratory, M‰lardalen University, Sweden

\bibitem{marketshare}
\textit{Gartner Smart Phone Marketshare 2013 Q4}, Gartner, Inc., 2013, saatavilla WWW-muodossa
<URL: \texttt{http://www.gartner.com/newsroom/id/2665715}, viitattu 02.04.2014.

\bibitem{iterative}
Craig Larman ja Victor Basili, \textit{Iterative and incremental developments. a brief history},
IEEE Computer Society, Volume: 36, Issue: 6, 2003.

\bibitem{valtiokonttori}
Valtiokonttori, Valtion IT-palvelukeskus, \textit{Ketter‰n palvelukehityksen ostaminen}, 2013. 

\bibitem{managing}
Winston Royce, \textit{Managing the development of large software systems},
Proceedings of IEEE WESCON, 1970.

\bibitem{spiral}
Barry Boehm, \textit{A spiral model of software development and enhancement},
ACM SIGSOFT Software engineering notes vol 11 no 4, 1986.

\bibitem{spiral2}
Barry Boehm, \textit{Spiral Development: Experience, Principles and Refinements},
Spiral Development Workshop, February 9, 2000.

\bibitem{scrumguide}
Ken Schwaber ja Jeff Sutherland, \textit{The Scrum Guide}, Scrum.org, 2013.

\bibitem{scrumkuva}
\textit{Scrum process}, saatavilla WWW-muodossa
<URL: \texttt{http://en.wikipedia.org/wiki/File:Scrum\_process.svg}>, viitattu 24.03.2014.

\bibitem{msretro}
David Starr, \textit{Effective Sprint Retrospectives}, 2012, saatavilla WWW-muodossa
<URL: \texttt{http://msdn.microsoft.com/en-us/library/jj620912.aspx}, viitattu 26.03.2014.

\bibitem{agilequality}
Ming Huo, June Verner, Liming Zhu ja Muhammad Ali Babar, \textit{Software Quality and Agile Methods}, 
Computer Software and Applications Conference, 2004. COMPSAC 2004. Proceedings of the 28th Annual International

\bibitem{ci}
Martin Fowler, \textit{Continuous Integration}, 2006, saatavilla WWW-muodossa
<URL: \texttt{http://martinfowler.com/articles/continuousIntegration.html}, viitattu 26.03.2014.

\bibitem{jenkins}
\textit{Jenkins - An extendable open source continuous integration server}, saatavilla WWW-muodossa
<URL: \texttt{http://jenkins-ci.org/}, viitattu 27.03.2014.

\bibitem{tddeff}
Hakan Erdogmus, Maurizio Morisio ja Marco Torchiano, \textit{On the Effectiveness of the Test-First Approach to Programming}, IEEE Transactions On Software Engineering, Vol. 31, No. 3, 2005

\bibitem{agilemanifesto}
\textit{Agile Manifesto}, 2001, saatavilla WWW-muodossa
<URL: \texttt{http://agilemanifesto.org/}>, viitattu 12.02.2013.

\bibitem{cucumberbook}
Matt Wayne ja Aslak Helles¯y, \textit{The Cucumber Book, Behaviour-Driven Development for Testers and Developers},
Pragmatic Programmers LLC, 2012.

\bibitem{bddcharacteristics}
Carlos SolÌs ja Xiaofeng Wang, \textit{A Study of the Characteristics of Behaviour Driven Development},
37th EUROMICRO Conference on Software Engineering and Advanced Applications, 2011.

\bibitem{bddintro}
Dan North, \textit{Introducing BDD}, 2006, saatavilla WWW-muodossa
<URL: \texttt{http://dannorth.net/introducing-bdd/}>, viitattu 27.01.2013.

\bibitem{specification}
Gojko Adzic, \textit{Specification by Example},
Manning Publications Co, 2011.

\bibitem{cucumber}
\textit{Cucumber - Making BDD fun}, saatavilla WWW-muodossa
<URL: \texttt{http://cukes.info/}>, viitattu 31.03.2014.

\bibitem{atdd}
B¯rge Haugset ja Tor StÂlhane, \textit{Automated Acceptance Testing as an Agile Requirements Engineering Practice},
45th Hawaii International Conference on System Sciences, 2012.

\bibitem{difference}
\textit{What is TDD, BDD \& ATDD?}, 2012, saatavilla WWW-muodossa
<URL: \texttt{http://assertselenium.com/2012/11/05/difference-between-tdd-bdd-atdd/}>, viitattu 31.03.2014.

\bibitem{bridging}
Gojko Adzic, \textit{Bridging the Communication Gap, Specification by Example and Agile Acceptance Testing},
Neuri Limited, 2009.

\bibitem{tdd}
Susan Hammond ja David Umphress, \textit{Test driven development: the state of the practice},
ACM-SE '12 Proceedings of the 50th Annual Southeast Regional Conference, s. 158-163, 2012.

\bibitem{tddbdd}
Liz Keogh, \textit{Translating TDD to BDD}, 2009, saatavilla WWW-muodossa
<URL: \texttt{http://lizkeogh.com/2009/11/06/translating-tdd-to-bdd/}>, viitattu 03.04.2014.

\bibitem{jasmine}
\textit{Jasmine: Behavior-Driven JavaScript}, saatavilla WWW-muodossa
<URL: \texttt{http://jasmine.github.io/}>, viitattu 07.04.2014.

\bibitem{specflow}
\textit{SpecFlow - Pragmatic BDD for .NET}, saatavilla WWW-muodossa
<URL: \texttt{http://www.specflow.org/}>, viitattu 07.04.2014.

\bibitem{rspec}
\textit{RSpec.info}, saatavilla WWW-muodossa
<URL: \texttt{http://rspec.info/}>, viitattu 07.04.2014.

\bibitem{gherkin}
\textit{Gherkin}, saatavilla WWW-muodossa
<URL: \texttt{https://github.com/cucumber/gherkin/}>, viitattu 09.04.2014.

\bibitem{gherkin2}
\textit{Cukes.info - Gherkin}, saatavilla WWW-muodossa
<URL: \texttt{http://cukes.info/gherkin.html}>, viitattu 10.04.2014. 

\bibitem{businessdsl}
Martin Fowler, \textit{BusinessReadableDSL}, saatavilla WWW-muodossa
<URL: \texttt{http://www.martinfowler.com/bliki/BusinessReadableDSL.html}>, viitattu 10.04.2014.

\bibitem{qualityrisk}
Bella‚j Salma, Kermad Lyes, Elmhamdi Abderahman ja BoujelbËne Younes, \textit{Quality Risk in Outsourcing},
International Conference on Service Systems and Service Management, 2007.

\bibitem{frank}
\textit{Testing With Frank - Painless iOS and Mac Testing With Cucumber}, saatavilla WWW-muodossa
<URL: \texttt{http://www.testingwithfrank.com/}>, viitattu 22.04.2014.

\bibitem{franksteps}
\textit{Frank/gem/lib/frank-cucumber/core\_frank\_steps.rb}, saatavilla WWW-muodossa
<URL: \texttt{https://github.com/moredip/Frank/blob/master/gem/lib/frank-cucumber/core\_frank\_steps.rb}>, viitattu 22.04.2014.

\bibitem{frankhelper}
\textit{Module: Frank::Cucumber::FrankHelper}, saatavilla WWW-muodossa
<URL: \texttt{http://rdoc.info/gems/frank-cucumber/Frank/Cucumber/FrankHelper}>, viitattu 22.04.2014.

\bibitem{kiwi}
\textit{allending/Kiwi}, saatavilla WWW-muodossa
<URL: \texttt{https://github.com/allending/Kiwi}>, viitattu 22.4.2014.

\bibitem{xcode}
\textit{Xcode - What's New - Apple Developer}, saatavilla WWW-muodossa
<URL: \texttt{https://developer.apple.com/xcode/}>, viitattu 22.4.2014.

\bibitem{calabash}
\textit{Calaba.sh - Automated Acceptance Testing for iOS and Android Apps}, saatavilla WWW-muodossa
<URL: \texttt{http://calaba.sh/}>, viitattu 22.04.2014.

\bibitem{calabashandroid}
\textit{Automated Functional testing for Android based on cucumber}, saatavilla WWW-muodossa
<URL: \texttt{https://github.com/calabash/calabash-android}>, viitattu 23.04.2014.

\bibitem{calabashios}
\textit{Calabash for iOS}, saatavilla WWW-muodossa
<URL: \texttt{https://github.com/calabash/calabash-ios}>, viitattu 23.04.2014.

\bibitem{xamarincloud}
\textit{Test mobile apps for every device using Xamarin Test Cloud}, saatavilla WWW-muodossa
<URL: \texttt{http://xamarin.com/test-cloud}, viitattu 23.04.2014.

\bibitem{robotium}
\textit{robotium - The world's leading Android test automation framework}, saatavilla WWW-muodossa
<URL: \texttt{https://code.google.com/p/robotium/}>, viitattu 23.04.2014.

\bibitem{cucumberandroid}
\textit{cucumber-jvm/examples/android}, saatavilla WWW-muodossa
<URL: \texttt{https://github.com/cucumber/cucumber-jvm/tree/master/examples/android}>, viitattu 23.04.2014

\bibitem{cucumberjvm}
\textit{Cucumber for the JVM}, saatavilla WWW-muodossa
<URL: \texttt{https://github.com/cucumber/cucumber-jvm}>, viitattu 23.04.2014

\end{thebibliography}

\end{document}
